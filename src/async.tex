\part{ASYNC}


\chapter{Overview}


\section{Network}

计算机科学中的异步通信（Asynchronous conferencing）特指以计算机为媒介，沟通，协作和学习，在互动贡献者中有一定延迟的技术。与之相对的是同步通信，广泛应用于各种“聊天”系统的用户“实时”同步通信。


异步传输模式（Asynchronous Transfer Mode，ATM）又叫信元中继，采用电路交换的方式，并以信元（cell）为单位。每个信元长53字节，其中报头占了5字节。

ATM能够比较理想地实现各种QoS，既能够支持有连接的业务，又能支持无连接的业务，因此成为了宽带ISDN（B-ISDN）技术的典范。

作为一种交换技术，ATM在发送数据时，先将数字数据切割成多个固定长度的数据包，之后利用光纤或DS1/ DS3发送。到达目的地后，再重新组合。

ATM网络可同时将声音、视频及数据集成在一起，从而可以针对各种信息型态提供最佳的传输环境。

HTTP/2是HTTP 1.1基于SPDY协议的更新\footnote{httpbis工作小组最初考虑了Google的SPDY协议、微软的SM协议和Network-Friendly HTTP更新，Facebook对各方案进行了评价并最终推荐了SPDY协议，HTTP 2.0的首个草稿于2012年11月发布，其内容基本和SPDY协议相同。}，其目标包括异步连接复用，头压缩和请求反馈管线化并保留与HTTP 1.1的完全语义兼容。


\subsection{Protocol}







\section{Process}


进程（process）是计算机中已运行程序的实体，也是分时系统的基本运作单位。

\begin{compactitem}
\item 在面向进程设计的系统（例如早期的UNIX，Linux 2.4及更早的版本），进程是程序的基本执行实体。
\item 在面向线程设计的系统（例如当代多数操作系统、Linux 2.6及更新的版本），进程本身不是基本运行单位，而是线程的容器。
\end{compactitem}

程序本身只是指令、数据及其组织形式的描述，如果程序没有被计算机执行，那么程序就只是硬盘上的一个文件而已，操作系统在计算机关闭后也仅仅是硬盘上的一组文件。

进程才是程序（那些指令和数据）的真正运行实例，若干进程有可能与同一个程序相关系，而且每个进程都可以以同步（循序）或异步（平行）的方式独立运行。

现代计算机系统可在同一段时间内以进程的形式将多个程序加载到存储器中，并通过时间共享（或称时分复用）来在一个处理器上表现出同时（平行性）运行的感觉。

多线程是每一个线程都代表一个进程内的一个独立执行上下文，因此使用多线程技术的操作系统或计算机架构可以让同样程序的平行线程真正同时运行在在多CPU主机或网络上（以及在不同的CPU上）。

\begin{compactitem}
\item 在批处理系统中，进程称为工作（jobs）；
\item 在分时系统中，进程称为用户程序（user progams）或任务（tasks）。
\item 在多数情况，工作与进程是同义词，但进程（process）已较为人接受。
\end{compactitem}

当用户下达运行程序的命令后，就会产生进程。同一程序可产生多个进程（一对多关系），这样就可以允许同时有多位用户运行同一程序，却不会相冲突。

进程需要一些资源才能完成工作，例如CPU使用时间、存储器、文件以及I/O设备，并且为依序逐一进行，因此每个CPU核心任何时间内仅能运行一个进程。

具体来说，一个计算机系统进程包括（或者说“拥有”）下列数据：

\begin{compactitem}
\item 那个程序的可运行机器码的一个在存储器的映像。\
\item 分配到的存储器（通常是虚拟的一个存储器区域）。存储器的内容包括可运行代码、特定于进程的数据（输入、输出）、调用堆栈、堆栈（用于保存运行时运输中途产生的数据）。
\item 分配给该进程的资源的操作系统描述符，诸如文件描述符（Unix术语）或文件句柄（Windows）、数据源和数据终端。

\item 安全特性，诸如进程拥有者和进程的权限集（可以容许的操作）。

\item 处理器状态（内文），诸如寄存器内容、物理存储器定址等。当进程正在运行时，状态通常存储在寄存器，其他情况在存储器。
\end{compactitem}

进程在运行时，状态（state）会改变，可以将进程状态理解为进程当前的动作：

\begin{compactitem}
\item 新生（new）：进程新产生中。
\item 运行（running）：正在运行。
\item 等待（waiting）：等待某事发生，例如等待用户输入完成。亦称“阻塞”（blocked）
\item 就绪（ready）：排班中，等待CPU。
\item 结束（terminated）：完成运行。
\end{compactitem}

进程的各个状态名称可能随不同操作系统而不同，例如对于单CPU系统，任何时间可能有多个进程为等待、就绪，但是必定仅有一个进程在运行。


\section{Thread}

线程（thread）是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位。

一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。

在Unix System V及SunOS中，线程也被称为轻量进程（lightweight processes），但是实际上轻量进程更多指内核线程（kernel thread），而把用户线程（user thread）称为线程。

作为独立调度和分派的基本单位，线程可以操作系统内核调度的内核线程（例如Win32线程），由用户进程自行调度的用户线程（例如Linux平台的POSIX Thread），或者由内核与用户进程（例如Windows 7的线程）等，进行混合调度。

同一进程中的多条线程将共享该进程中的全部系统资源，例如虚拟地址空间，文件描述符和信号处理等，但是同一进程中的多个线程有各自的调用栈（call stack），自己的寄存器环境（register context），自己的线程本地存储（thread-local storage）。



一个进程可以有很多线程，每条线程并行执行不同的任务。

在多核或多CPU，或支持Hyper-threading的CPU上使用多线程程序设计的好处是显而易见，即提高了程序的执行吞吐率。

在单CPU单核的计算机上，使用多线程技术，也可以把进程中负责IO处理、人机交互而常备阻塞的部分与密集计算的部分分开来执行，编写专门的workhorse线程执行密集计算，从而提高了程序的执行效率。

与进程的状态不同，线程有四种基本状态，分别为：

\begin{compactitem}
\item 产生（spawn）
\item 中断（block）
\item 非中断（unblock）
\item 结束（finish）
\end{compactitem}

\subsection{UNIX  International}

SUN Solaris操作系统使用的线程叫做UNIX International线程，支持内核线程、轻权进程和用户线程。

一个进程可有大量用户线程，大量用户线程复用少量的轻权进程，轻权进程与内核线程一一对应。用户级线程在调用核心服务时（如文件读写），需要“捆绑（bound）”在一个lwp上。

\begin{compactitem}
\item 永久捆绑（一个LWP固定被一个用户级线程占用，该LWP移到LWP池之外）；
\item 临时捆绑（从LWP池中临时分配一个未被占用的LWP）
\end{compactitem}

在调用系统服务时，如果所有LWP已被其他用户级线程所占用（捆绑），则该线程阻塞直到有可用的LWP。如果LWP执行系统线程时阻塞（如read()调用），则当前捆绑在LWP上的用户级线程也阻塞。

UNIX International线程的头文件是<thread.h>。

\begin{compactitem}
\item 创建用户级线程

\begin{lstlisting}[language=PHP]
int thr_create(void * stack_base, size_t stack_size, void *(*start_routine，void *), void * arg, long flags, thread_t * new_thr);
\end{lstlisting}

其中flags包括：THR\_BOUND（永久捆绑）, THR\_NEW\_LWP（创建新LWP放入LWP池），若两者同时指定则创建两个新LWP，一个永久捆绑而另一个放入LWP池。

\item 等待用户级线程

\begin{lstlisting}[language=PHP]
int thr_join(thread_t wait_for, thread_t *dead, void **status);
\end{lstlisting}

\item 挂起用户级线程

\begin{lstlisting}[language=PHP]
int thr_suspend(thread_t thr);
\end{lstlisting}

\item 继续用户级线程

\begin{lstlisting}[language=PHP]
int thr_continue(thread_t thr);
\end{lstlisting}

\item 退出用户级线程

\begin{lstlisting}[language=PHP]
void thr_exit(void *status);
\end{lstlisting}

\item 返回当前用户级线程的线程标识符

\begin{lstlisting}[language=PHP]
thread_t thr_self( void );
\end{lstlisting}

\end{compactitem}

\subsection{POSIX Thread}

POSIX线程（POSIX threads），简称Pthreads，是线程的POSIX标准。该标准定义了创建和操纵线程的一整套API。


在类Unix操作系统（Unix、Linux、Mac OS X等）中，都使用Pthreads作为操作系统的线程，Windows操作系统也有其移植版pthreads-win32。

Pthreads定义了一套C语言的类型、函数与常量，它以pthread.h头文件和一个线程库实现。

Pthreads API中大致共有100个函数调用，全都以"pthread\_"开头，并可以分为四类：

\begin{compactitem}
\item 线程管理，例如创建线程，等待(join)线程，查询线程状态等。
\item Mutex：创建、摧毁、锁定、解锁、设置属性等操作
\item 条件变量（Condition Variable）：创建、摧毁、等待、通知、设置与查询属性等操作
\item 使用了读写锁的线程间的同步管理
\end{compactitem}

POSIX的Semaphore API可以和Pthreads协同工作，但这并不是Pthreads的标准，因而这部分API是以\texttt{"sem\_"}打头，而非\texttt{"pthread\_"}。



\begin{compactitem}
\item 创建用户级线程

\begin{lstlisting}[language=PHP]
int pthread_create(pthread_t * thread, const pthread_attr_t * attr, void *(*start_routine)(void *), void *arg);
\end{lstlisting}

\item 等待用户级线程

\begin{lstlisting}[language=PHP]
int pthread_join(pthread_t thread, void ** retval);
\end{lstlisting}

\item 退出用户级线程

\begin{lstlisting}[language=PHP]
void pthread_exit(void *retval);
\end{lstlisting}

\item 返回当前用户级线程的线程标识符

\begin{lstlisting}[language=PHP]
pthread_t pthread_self(void);
\end{lstlisting}

\item 用户级线程的取消

\begin{lstlisting}[language=PHP]
int pthread_cancel(pthread_t thread);
\end{lstlisting}

\end{compactitem}


\subsection{Win32 Thread}

Win32线程是Windows API的一部分，其上下文包括寄存器、核心栈、线程环境块和用户栈。

Win32线程的头文件是<Windows.h>，仅适用于Windows操作系统。



\begin{compactitem}
\item 创建用户级线程

\begin{lstlisting}[language=PHP]
HANDLE WINAPI CreateThread(LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId);
\end{lstlisting}

\item 结束本线程

\begin{lstlisting}[language=PHP]
VOID WINAPI ExitThread(DWORD dwExitCode);
\end{lstlisting}



\item 挂起指定的线程

\begin{lstlisting}[language=PHP]
DWORD WINAPI SuspendThread( HANDLE hThread );
\end{lstlisting}

\item 恢复指定线程运行

\begin{lstlisting}[language=PHP]
DWORD WINAPI ResumeThread(HANDLE hThread);
\end{lstlisting}



\item 等待线程运行完毕

\begin{lstlisting}[language=PHP]
DWORD WINAPI WaitForSingleObject(HANDLE hHandle, DWORD dwMilliseconds);
\end{lstlisting}

\item 返回当前线程的线程标识符

\begin{lstlisting}[language=PHP]
DWORD WINAPI GetCurrentThreadId(void);
\end{lstlisting}

\item 返回当前线程的线程句柄

\begin{lstlisting}[language=PHP]
HANDLE WINAPI GetCurrentThread(void);
\end{lstlisting}

\end{compactitem}

\subsection{C++11 Thread}

2011年8月12日，国际标准化组织（ISO）发布了第三个C++标准，即ISO/IEC 14882:2011，简称ISO C++ 11标准。该标准第一次把线程的概念引入C++标准库。Windows平台运行的VS2012和Linux平台运行的g++4.7，都完美支持C++11线程。

C++ 11线程的头文件是<thread>

\begin{compactitem}
\item 创建线程

\begin{lstlisting}[language=PHP]
std::thread::thread(Function&& f, Args&&... args);
\end{lstlisting}

\item 等待线程结束

\begin{lstlisting}[language=PHP]
std::thread::join();
\end{lstlisting}

\item 脱离线程控制

\begin{lstlisting}[language=PHP]
std::thread::detach();
\end{lstlisting}


\item 交换线程

\begin{lstlisting}[language=PHP]
std::thread::swap(thread& other);
\end{lstlisting}
\end{compactitem}


\subsection{C11 Thread}


2011年12月8日，国际标准化组织（ISO）发布了第三个C语言标准，即ISO 9899:2011，简称ISO C 11标准。该标准第一次把线程的概念引入C语言标准库。

C11线程仅仅是个“建议标准”，也就是说100\%遵守C11标准的C编译器是可以不支持C11线程的。根据C11标准的规定，只要编译器预定义了\_\_STDC\_NO\_THREADS\_\_宏，就可以没有<threads.h>头文件，自然也就也没有下列函数。

C11线程的头文件是<threads.h>

\begin{compactitem}
\item 创建线程

\begin{lstlisting}[language=PHP]
int thrd_create(thrd_t *thr, thrd_start_t func, void *arg);
\end{lstlisting}


\item 结束本线程

\begin{lstlisting}[language=PHP]
_Noreturn void thrd_exit( int res );
\end{lstlisting}

\item 等待线程运行完毕

\begin{lstlisting}[language=PHP]
int thrd_join(thrd_t thr, int *res);
\end{lstlisting}

\item 返回当前线程的线程标识符

\begin{lstlisting}[language=PHP]
thrd_t thrd_current();
\end{lstlisting}
\end{compactitem}

\subsection{Java Thread}

\begin{compactitem}
\item 最简单的情况是，Thread/Runnable的run()方法运行完毕，自行终止。
\item 对于更复杂的情况，比如有循环，则可以增加终止标记变量和任务终止的检查点。
\item 最常见的情况，也是为了解决阻塞不能执行检查点的问题，用中断来结束线程，但中断只是请求，并不能完全保证线程被终止，需要执行线程协同处理。
\item IO阻塞和等锁情况下需要通过特殊方式进行处理。
\item 使用Future类的cancel()方法调用。
\item 调用线程池执行器的shutdown()和shutdownNow()方法。
\item 守护线程会在非守护线程都结束时自动终止。
\item Thread有stop()方法，但已不推荐使用。
\end{compactitem}


\subsection{Multi Thread}

多线程（multithreading）是指从软件或者硬件上实现多个线程并发执行的技术。

具有多线程能力的计算机因有硬件支持而能够在同一时间执行多于一个线程，进而提升整体处理性能，具有多线程能力的系统包括对称多处理机、多核心处理器以及芯片级多处理（Chip-level multithreading）或同时多线程（Simultaneous multithreading）处理器。

程序代码中存在的数据及控制依赖关系使得单线程中所能发掘的指令并行潜力是有限的，因此为了发掘有限的指令级并行潜力而一味强化乱序执行和分支预测，以至于处理器复杂度和功耗急剧上升，有时候是得不偿失的。

现代微处理器多采用硬件多线程技术来发掘线程之间的线程级并行潜力，这样就允许在接口转换的专业领域运算能力大幅提升。

\begin{compactitem}
\item 既使这样做对于提升单一程序或是线程的性能相当困难，但是目前多数的系统都是使用多任务的方式作业。
\item 能够明显的提升整体系统运算能力，总体吞吐量获得提升。
\end{compactitem}



即便处理器只能运行一个线程，操作系统也可以通过快速的在不同线程之间进行切换，由于时间间隔很小，来给用户造成一种多个线程同时运行的假象。这样的程序运行机制被称为软件多线程。例如，微软的Windows作业系统和Linux就是在各个不同的执行绪间来回切换，被称为单用户多任务作业系统，但是DOS这类文字接口作业系统在一个时间只能处理一项工作，因此被视为单用户单任务系统。

除此之外，许多系统及处理器也支持硬件多线程技术。例如，对称多处理机（SMP）系统具有多个处理器，所以具有真正的同时执行多个线程的能力，CMP技术通过在一块芯片上集成多个核心（Core）也具有真正的多线程能力。

CMT技术则稍有不同，有的是依靠硬件执行线程切换来获得多线程能力，操作系统不再负责线程切换，因而这部分开销可以减少甚至消除，这方面典型的例子是Sun的UltraSPARC T1，它同时综合了CMP和CMT，微软的Windows 2000以后的操作系统皆支持多线程与超线程技术。

对于现在的两种提升运算能力的主要技术多进程和多线程，当共享硬件资源（例如缓存或是TLB）时多线程会造成干预，而且单线程的运行时间可能不会因为多线程而变短，不过硬件侦测技术有可能改变这一状况。

多线程的硬件支持会牵涉到软件支持，如此程序与操作系统就需要比多过程化更大幅度的修改。

在粗粒度交替多线程系统中，一个线程持续运行直到该线程被一个事件挡住而制造出长时间的延迟(可能是内存load/store操作，或者程序分支操作)。该延迟通常是因缓存失败而从核心外的内存读写，而这动作会使用到几百个CPU周期才能将数据回传。与其要等待延迟的时间，线程化处理器会切换运行到另一个已就绪的线程。只要当之前线程中的数据送达后，上一个线程就会变成已就绪的线程。这种方法来自各个线程的指令交替执行，可以有效的掩盖内存访问时延，填补流水线空洞。

举例来说：

\begin{compactenum}
\item 周期 i ：接收线程 A 的指令 j
\item 周期 i+1：接收线程 A 的指令 j+1
\item 周期 i+2：接收线程 A 的指令 j+2，而这指令缓存失败
\item 周期 i+3：线程调度器介入，切换到线程 B
\item 周期 i+4：接收线程 B 的指令 k
\item 周期 i+5：接收线程 B 的指令 k+1
\end{compactenum}

在概念上，粗粒度交替多线程系统与实时操作系统中使用的合作式多任务类似，在该任务需要为一个事件等待一段时间的时候会主动放弃运行时段。

粗粒度交替多线程系统的硬件支持的目标是允许在挡住的线程与已就绪的线程中快速切换。为了要达成这个目标，硬件成本将复制程序看得见的寄存器与一些处理器控制寄存器（像是程序计算器）。从一个线程切换到另一个线程对硬件来讲意谓著从一个寄存器复制到另一个。

\begin{compactitem}
\item 线程切换能够在一个 CPU 周期内完成(实际上可以没有开销，上个周期在运行线程A，下个周期就已在运行线程B)。
\item 每个线程是独自运行的，没有其他线程与目前共享硬件资源。对操作系统来说，通常每个虚拟线程都被视做一个处理器。这样就不需要很大的软件变更（像是特别写支持多线程的操作系统）。
\end{compactitem}

为了要在各个现行中的线程有效率的切换，每个现行中的线程需要有自己的暂存设置（register set）。像是为了能在两个线程中快速切换，硬件的寄存器需要两次例示（instantiated）。

许多微控制器与嵌入式处理器有多重的寄存器列，就能够在中断时快速环境切换，这样架构可以视为程序的线程与中断线程之间的块状多线程处理。


细粒度交替式多线程系统提供了更高性能的多线程做法，所有 CPU 周期轮流切换至不同的线程，来自各线程的指令按顺序交替执行，整个执行过程很像桶形处理器(Barrel Processor)。

\begin{compactenum}
\item 周期 i ：接收线程 A 的一个指令
\item 周期 i+1：接收线程 B 的一个指令
\item 周期 i+2：接收线程 C 的一个指令
\end{compactenum}

细粒度交替式多线程的效果是会将所有从运行管线中的数据从属（data dependency）关系移除掉。因为每个线程是相对独立，管线中的一个指令层次结构需要从已跑完管线中的较旧指令代入输出的机会就相对的变小了。

在概念上，细粒度交替式多线程与操作系统的核心先占多任务（pre-exemptive multitasking）相似。

除了讨论块状多线程的硬件成本，交错式多线程也因每层管线需要追踪运行中指令的线程代码而增加硬件成本。而且，当越来越多的线程同时在管线中运行，像是缓存与 TLB 等共享资源也要加大来避免不同线程之间的冲突。

目前，最先进的多线程技术是应用在超标量处理器上的同步多线程，超标量处理器内在每个CPU周期中，单独一个线程会发布众多的指令。应用同步多线程(SMT)之后，超标量处理器就可以在每个CPU周期中，从多个线程中发布指令。辨识到任何一个单一线程拥有有限数量的指令平行处理，这种类型的多线程是试着利用并行的方式跨越多线程，以减少浪费与闲置的资源。 举例来说：

\begin{compactenum}
\item 周期 i：线程 A 的 j 指令 与 j+1 指令，还有 B 线程的指令 k 同时发布
\item 周期 i+1：线程 A 的 j+2 指令、线程 B 的 k+1指令，与线程 C 的 m 指令同时发布
\item 周期 i+2：线程 A 的 j+3 指令，与线程 C 的 m+1 与 m+2 指令同时发布
\end{compactenum}

交错式多线程如果不计硬件成本，SMT在每个管线层次结构的追踪线程指令会有多余的花费，而且缓存与TLB等共享的资源可能会因为多出来的线程而变得更大。


在大多数研究领域内是要求线程调度器要能够快速选择其中一个已就绪线程去运行，而不是一个一个运行而降低效率。所以要让调度器去分辨线程的优先级是很重要的。而线程调度器可能是以硬件、软件，或是软硬件并存的形式存在。

另一个研究领域则是要研究何种事件（缓存失败、内部运行续连系、使用DMA等）会造成线程切换。

如果多线程的方案会复制所有软件可见的状态，包括特许的控制登录、TLB 等，那就能够让虚拟机去创造各式线程，这样就允许在相同的处理器中每个线程跑各自的操作系统。换句话说，如果只有存储了用户模式的状态，就能够让相同的裸晶大小的芯片在一段时间内处理更多的线程。

\subsection{Thread Pool}

线程池（Thread Pool）是一种成熟的线程使用模式， 实现有领导者与跟随者模式和半同步半异步模式。

线程池的伸缩性对性能有较大的影响。

\begin{compactitem}
\item 创建太多线程，将会浪费一定的资源，有些线程未被充分使用。
\item 销毁太多线程，将导致之后浪费时间再次创建它们。
\item 创建线程太慢，将会导致长时间的等待，性能变差。
\item 销毁线程太慢，导致其它线程资源饥饿。
\end{compactitem}

\section{Interrupt}

在计算机科学中，中断（Interrupt）是指处理器接收到来自硬件或软件的信号，提示发生了某个事件，应该被注意，这种情况就称为中断。

通常，在接收到来自外围硬件（相对于中央处理器和内存）的异步信号，或来自软件的同步信号之后，处理器将会进行相应的硬件/软件处理。发出这样的信号称为进行中断请求（interrupt request，IRQ）。

\begin{compactitem}
\item 硬件中断导致处理器通过一个运行信息切换（context switch）来保存执行状态（以程序计数器和程序状态字等寄存器信息为主）。

\begin{compactenum}
\item 可屏蔽中断（maskable interrupt）。硬件中断的一类，可通过在中断屏蔽寄存器中设定位掩码来关闭。
\item 非可屏蔽中断（non-maskable interrupt，NMI）。硬件中断的一类，无法通过在中断屏蔽寄存器中设定位掩码来关闭。典型例子是时钟中断（一个硬件时钟以恒定频率—如50Hz—发出的中断）。
\item 处理器间中断（interprocessor interrupt）。一种特殊的硬件中断。由处理器发出，被其它处理器接收。仅见于多处理器系统，以便于处理器间通信或同步。
\item 伪中断（spurious interrupt）。一类不希望被产生的硬件中断。发生的原因有很多种，如中断线路上电气信号异常，或是中断请求设备本身有问题。
\end{compactenum}

\item 软件中断则通常作为CPU指令集中的一个指令，以可编程的方式直接指示这种运行信息切换，并将处理导向一段中断处理代码。

\begin{compactenum}
\item 软件中断。是一条CPU指令，用以自陷一个中断。由于软中断指令通常要运行一个切换CPU至内核态（Kernel Mode/Ring 0）的子例程，它常被用作实现系统调用（System call）。
\end{compactenum}

\end{compactitem}

处理器通常含有一个内部中断屏蔽位，并允许通过软件来设定。一旦被设定，所有外部中断都将被系统忽略。这个屏蔽位的访问速度显然快于中断控制器上的中断屏蔽寄存器，因此可提供更快速地中断屏蔽控制。

如果一个中断使得机器处于一种确定状态，则称为精确中断（precise interrupt）。精确中断须保证：

\begin{compactitem}
\item 程序计数器的值被保存在已知位置。
\item 程序计数器所指向的指令之前的所有指令已被执行完毕。
\item 程序计数器所指向的指令之后的所有指令不可被执行。如果中断信号到来后而转入处理前发生了任何针对寄存器/内存的更改，都必须予以还原。
\item 程序计数器所指向的指令地执行状态已知。
\end{compactitem}


如果无法满足以上条件，此中断被称作非精确中断（imprecise interrupt）。

中断在计算机多任务处理，尤其是实时系统中尤为有用，这样的系统（包括运行于其上的操作系统）也被称为“中断驱动的”（interrupt-driven）。


中断尽管可以提高计算机处理性能，但是过于密集的中断请求/响应反而会影响系统性能，这类情形被称作中断风暴（interrupt storm），与中断处理相对的是轮询（Polling）。

轮询（Polling）是一种CPU决策如何提供周边设备服务的方式，又称“程控输出入”（Programmed I/O），其过程是由CPU定时发出询问，依序询问每一个周边设备是否需要其服务，有即给予服务，服务结束后再问下一个周边，接着不断周而复始，问题是虽然轮询法实现容易，但是效率偏低。

中断是用以提高计算机工作效率、增强计算机功能的一项重要技术。最初引入硬件中断，只是出于性能上的考量。如果计算机系统没有中断，则处理器与外部设备通信时，它必须在向该设备发出指令后进行忙等待(Busy waiting)，反复轮询该设备是否完成了动作并返回结果，从而造成了大量处理器周期被浪费。

引入中断以后，当处理器发出设备请求后就可以立即返回以处理其他任务，而当设备完成动作后，发送中断信号给处理器，后者就可以再回过头获取处理结果。这样，在设备进行处理的周期内，处理器可以执行其他一些有意义的工作，而只付出一些很小的切换所引发的时间代价。后来被用于CPU外部与内部紧急事件的处理、机器故障的处理、时间控制等多个方面，并产生通过软件方式进入中断处理（软中断）的概念。

在硬件实现上，中断可以是一个包含控制线路的独立系统，也可以被集成进存储器子系统中。对于前者，在IBM个人机上，广泛使用可编程中断控制器（Programmable Interrupt Controller，PIC）来负责中断响应和处理。PIC被连接在若干中断请求设备和处理器的中断引脚之间，从而实现对处理器中断请求线路（多为一针或两针）的复用。

作为另一种中断实现的形式，即存储器子系统实现方式，可以将中断端口映射到存储器的地址空间，这样对特定存储器地址的访问实际上是中断请求。




\section{Signal}

在计算机科学中，信号（Signals）是Unix、类Unix以及其他POSIX兼容的操作系统中进程间通讯的一种有限制的方式。

信号是一种异步的通知机制，用来提醒进程一个事件已经发生。当一个信号发送给一个进程，操作系统中断了进程正常的控制流程，此时，任何非原子操作都将被中断。如果进程定义了信号的处理函数，那么它将被执行，否则就执行默认的处理函数。

在一个运行的程序的控制终端键入特定的组合键可以向它发送某些信号：

\begin{compactitem}
\item Ctrl-C发送INT信号（SIGINT）：默认情况下，这会导致进程终止。
\item Ctrl-Z发送TSTP信号（SIGTSTP）：默认情况下，这会导致进程挂起。
\item Ctrl-\textbackslash 发送QUIT信号（SIGQUIT）：默认情况下，这会导致进程终止并且将内存中的信息转储到硬盘（核心转储）。
\item 这些组合键可以通过stty命令来修改。
\end{compactitem}

kill()系统调用会在权限允许的情况下向进程发送特定的信号，类似地kill命令允许用户向进程发送信号，raise(3)库函数可以将特定信号发送给当前进程。

另外，除数为零、段错误等异常也会产生信号（这里分别是SIGFPE和SIGSEGV，默认都会导致进程终止和核心转储）。

内核可以向进程发送信号以告知它一个事件发生了。例如，当进程将数据写入一个已经被关闭的渠道是将会收到SIGPIPE信号，默认情况下会使进程关闭。

信号处理函数可以通过signal()系统调用来设置。如果没有为一个信号设置对应的处理函数，就会使用默认的处理函数，否则信号就被进程截获并调用相应的处理函数。

在没有处理函数的情况下，程序可以指定两种行为：忽略这个信号（SIG\_IGN）或者用默认的处理函数（SIG\_DFL），但是有两个信号是无法被截获并处理的：SIGKILL和SIGSTOP。

竞态条件的存在和信号本身的异步特性使信号的处理有弱点，所以在处理一个信号的过程中，进程可能收到另一个信号（甚至是相同的信号）。

sigprocmask()系统调用可以用来阻塞和恢复信号的传递，信号可以造成进程中系统调用的中断，并在信号处理完后重新开始未完成的系统调用。

在实践中，信号处理函数应该没有任何不想要的副作用，比如errno的改变、信号掩码的改变、信号处理方法的改变，以及其他全局进程性质的改变。在信号处理函数内使用不可重入函数（例如malloc和printf）也是不安全的。

进程的运行也可能导致硬件异常，例如，在类Unix系统中将一个数除以零，或者出现TLB不命中都会自动运行内核的异常处理程序。

对于某些异常如页缺失，内核有足够的信息来处理完并恢复进程的运行。但是对于另外一些异常，内核不能处理而只能通过发送信号把异常交给进程自己处理。例如，在x86架构的CPU上，如果一个进程尝试将一个数除以零，将会产生divide error异常，并使内核向出错的进程发送SIGFPE信号。相似地，如果一个进程尝试访问虚拟地址空间以外的内存，内核将向进程发送SIGSEGV信号。异常与信号的具体对应关系在不同的CPU架构上是不同的。



\section{Queue}


\subsection{Message Passing}

在计算机科学中，消息传递（Message passing）是一种通讯的形式，其主要的数学模型为参与者模式、π-calculus，并且应用在并发计算、并行计算、面向对象程序设计与进程间通讯中，进程或对象以发送及接收消息的方式来达成同步。

不同于传统程序设计通过名字直接调用（invoking）一个进程、子例程或者函数，消息传递直接发送消息给一个进程，依赖进程或基础框架来调用实际执行的代码，并且可以分为同步方式与异步方式。

消息传递是一种通讯范型，在这种模型中由一个传信者将消息（messages）送给一个或多个收信者。

根据操作系统与编程语言的支持，消息的形式有所不同，常见的有方法（method）、信号（signals）与数据包（data packets）。

实际应用的消息传递系统有开放网络运算远程过程调用（ONC RPC）、CORBA、Java RMI、Distributed COM、SOAP。



\subsection{Messager Queue}


在计算机科学中，消息队列（Message queue）是一种进程间通信或同一进程的不同线程间的通信方式，软件的队列用来处理一系列的输入，通常是来自使用者。

消息队列提供了异步的通信协议，每一个队列中的记录包含详细说明的信息，包含发生的时间，输入装置的种类，以及特定的输入参数，也就是说消息的发送者和接收者不需要同时与消息队列交互，这样消息就会保存在队列中，直到接收者取回它。

一个 WIMP 环境（例如Microsoft Windows）可以通过优先的某些形式（通常是事件的时间或是重要性的顺序）来存储使用者产生的事件到一个事件队列中，然后系统把每个事件从事件队列中传递给目标的应用程序。


目前，有很多消息队列有很多开源的实现，包括JBoss Messaging、JORAM、Apache ActiveMQ、Sun Open Message Queue、Apache Qpid和HTTPSQS等。

实际上，消息队列常常保存在链表结构中，因此消息队列有大小限制，只有拥有权限的进程可以向消息队列中写入或读取消息。

消息队列本身是异步的，它允许接收者在消息发送很长时间后再取回消息，这导致了和大多数通信协议的不同。例如，HTTP协议就是同步的，客户端在发出请求后必须等待服务器回应。

不过，在很多情况下我们需要异步\footnote{消息队列非常独特，其本质就是一个消息的链表，因此两个进程不必同时存在，一个进程可以发送一个消息并退出，而该消息可以在数天后才被另一个进程获得。}的通信协议。例如，一个进程通知另一个进程发生了一个事件，但是不需要等待回应。

消息队列的异步特点也造成了一个缺点，就是接收者必须轮询消息队列，才能收到最近的消息。

\begin{compactitem}
\item 和信号相比，消息队列能够传递更多的信息。
\item 与管道相比，消息队列提供了有格式的数据。
\end{compactitem}


\subsection{Messager Service}

Java消息服务（Java Message Service，JMS）应用程序接口是一个Java平台中关于面向消息中间件（MOM）的API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。

Java消息服务本身是一个与具体平台无关的API，绝大多数MOM提供商都对JMS提供支持。

Java消息服务的规范包括两种消息模式，点对点和发布者/订阅者，用户可以在他们的分布式软件中实现面向消息的操作，这些操作将具有不同面向消息中间件产品的可移植性。

Java消息服务支持同步和异步的消息处理，在某些场景下，异步消息是必要的，而且在其他场景下异步消息可能比同步消息操作更加便利。

Java消息服务支持面向事件的方法接收消息，事件驱动的程序设计现在被广泛认为是一种富有成效的程序设计范例，这样在应用系统开发时，Java消息服务可以推迟选择面对消息中间件产品，也可以在不同的面对消息中间件切换。

JMS由以下元素组成：

\begin{compactitem}
\item JMS提供者
连接面向消息中间件的，JMS接口的一个实现。提供者可以是Java平台的JMS实现，也可以是非Java平台的面向消息中间件的适配器。
\item JMS客户
生产或消费消息的基于Java的应用程序或对象。
\item JMS生产者
创建并发送消息的JMS客户。
\item JMS消费者
接收消息的JMS客户。
\item JMS消息
包括可以在JMS客户之间传递的数据的对象
\item JMS队列
一个容纳那些被发送的等待阅读的消息的区域。队列暗示，这些消息将按照顺序发送。一旦一个消息被阅读，该消息将被从队列中移走。
\item JMS主题
一种支持发送消息给多个订阅者的机制。
\end{compactitem}

Java消息服务应用程序结构支持两种模型：

\begin{compactitem}
\item 点对点或队列模型
\item 发布/订阅模型
\end{compactitem}

在点对点或队列模型下，一个生产者向一个特定的队列发布消息，一个消费者从该队列中读取消息。这里，生产者知道消费者的队列，并直接将消息发送到消费者的队列，因此这种模式被概括为：

\begin{compactitem}
\item 只有一个消费者将获得消息
\item 生产者不需要在接收者消费该消息期间处于运行状态，接收者也同样不需要在消息发送时处于运行状态。
\item 每一个成功处理的消息都由接收者签收
\end{compactitem}

发布者/订阅者模型支持向一个特定的消息主题发布消息，0或多个订阅者可能对接收来自特定消息主题的消息感兴趣。

在发布者/订阅者模型下，发布者和订阅者彼此不知道对方，因此这种模式好比是匿名公告板，可以被概括为：

\begin{compactitem}
\item 多个消费者可以获得消息
\item 在发布者和订阅者之间存在时间依赖性。发布者需要建立一个订阅（subscription），以便客户能够购订阅。订阅者必须保持持续的活动状态以接收消息，除非订阅者建立了持久的订阅。在那种情况下，在订阅者未连接时发布的消息将在订阅者重新连接时重新发布。
\end{compactitem}

JMS提供了将应用与提供数据的传输层相分离的方式，同一组Java类可以通过JNDI中关于提供者的信息，连接不同的JMS提供者。这一组类首先使用一个连接工厂以连接到队列或主题，然后发送或发布消息。在接收端，客户接收或订阅这些消息。

Java消息服务的API在javax.jms包中提供，具体内容包括：

\begin{compactitem}
\item ConnectionFactory 接口（连接工厂）

用户用来创建到JMS提供者的连接的被管对象。JMS客户通过可移植的接口访问连接，这样当下层的实现改变时，代码不需要进行修改。 管理员在JNDI名字空间中配置连接工厂，这样，JMS客户才能够查找到它们。根据消息类型的不同，用户将使用队列连接工厂，或者主题连接工厂。



\item Connection 接口（连接）

连接代表了应用程序和消息服务器之间的通信链路。在获得了连接工厂后，就可以创建一个与JMS提供者的连接。根据不同的连接类型，连接允许用户创建会话，以发送和接收队列和主题到目标。



\item Destination 接口（目标）

目标是一个包装了消息目标标识符的被管对象，消息目标是指消息发布和接收的地点，或者是队列，或者是主题。JMS管理员创建这些对象，然后用户通过JNDI发现它们。和连接工厂一样，管理员可以创建两种类型的目标，点对点模型的队列，以及发布者／订阅者模型的主题。



\item MessageConsumer 接口（消息消费者）

由会话创建的对象，用于接收发送到目标的消息。消费者可以同步地（阻塞模式），或异步（非阻塞）接收队列和主题类型的消息。



\item MessageProducer 接口（消息生产者）

由会话创建的对象，用于发送消息到目标。用户可以创建某个目标的发送者，也可以创建一个通用的发送者，在发送消息时指定目标。



\item Message 接口（消息）

是在消费者和生产者之间传送的对象，也就是说从一个应用程序创送到另一个应用程序。一个消息有三个主要部分：

\begin{compactenum}
\item 消息头（必须）：包含用于识别和为消息寻找路由的操作设置。
\item 一组消息属性（可选）：包含额外的属性，支持其他提供者和用户的兼容。可以创建定制的字段和过滤器（消息选择器）。
\item 一个消息体（可选）：允许用户创建五种类型的消息（文本消息，映射消息，字节消息，流消息和对象消息）。
\end{compactenum}

消息接口非常灵活，并提供了许多方式来定制消息的内容。

\item Session 接口（会话）

表示一个单线程的上下文，用于发送和接收消息。由于会话是单线程的，所以消息是连续的，就是说消息是按照发送的顺序一个一个接收的。会话的好处是它支持事务。如果用户选择了事务支持，会话上下文将保存一组消息，直到事务被提交才发送这些消息。在提交事务之前，用户可以使用回滚操作取消这些消息。一个会话允许用户创建消息生产者来发送消息，创建消息消费者来接收消息。

\end{compactitem}

要使用Java消息服务，必须要有一个JMS提供者来管理会话和队列。现在既有开源的提供者也有专有的提供者。

如果计划在一个服务器集群中运行程序，需要检查提供者是否实现了对负载均衡和故障恢复的支持。

\section{Async}


\subsection{AJAX}

AJAX（Asynchronous JavaScript and XML，异步的JavaScript与XML技术）综合了多项技术来支持浏览器端的网页开发。

与传统的Web应用允许用户端填写表单（form）并提交不同，当用户提交表单时就向Web服务器发送一个请求，服务器接收并处理传来的表单，然后送回一个新的网页，这个做法浪费了许多带宽。

在前后两个页面中的大部分HTML码往往是相同的，每次应用的沟通都需要向服务器发送请求，应用的回应时间依赖于服务器的回应时间，因此这也导致了用户界面的回应比本机应用慢得多。

AJAX应用可以仅向服务器发送并取回必须的数据，并在客户端采用JavaScript处理来自服务器的回应，在服务器和浏览器之间交换的数据大量减少（大约只有原来的5\%），因此服务器回应更快了。同时，很多的处理工作可以在发出请求的客户端机器上完成，因此Web服务器的负荷也减少了。

类似于DHTML或LAMP，AJAX不是指一种单一的技术，而是有机地利用了一系列相关的技术。例如，虽然其名称包含XML，但实际上数据格式可以由JSON代替以进一步减少数据量，形成所谓的AJAJ。

客户端与服务器也可以不需要异步，例如一些基于AJAX的“派生/合成”式（derivative/composite）的技术也正在出现，如AFLAX。





\subsection{Method}

异步方法调用或异步方法模式是（多线程）面向对象程序设计中用于异步调用对象的潜在的长期运行方法的一种设计模式。

异步方法调用等价于Allan Vermeulen提出的IOU模式，基于事件的异步模式是异步方法调用的一个变种，开销更大但能更好的表现软件组件对象。

.NET框架和Java中的java.util.concurrent.FutureTask类中使用的基于事件的异步模式使用事件来解决同样的问题，而且异步事件处理函数库libevent通过一组API来让用户可以设定某些事件发生时所执行的函数，也就是说，libevent可以用来取代网络服务器所使用的事件循环检查框架。



具体来说，libevent支持poll、select、/dev/pool、kqueue和epoll等方式来判断IO事件，这样libevent就省略了对网络的处理，并且拥有不错的性能，因此被memcached和tor等软件作为网络底层的函数库。

大部分编程语言中对方法的调用是同步执行的。例如，在线程执行体内（即线程的调用函数中），方法的调用就是同步执行的。

如果方法需要很长的时间来完成，比方说从Internet加载数据的方法，调用者线程将被阻塞直到方法调用完成。如果不希望调用被阻塞，则可以通过创建新的worker线程并在worker线程中调用方法，在大多数编程环中上这样做可能需要很长的一段代码，尤其是需要小心处理线程过多的额外开销。

异步方法调用它通过使用一种立即返回的异步的变体并提供额外的方法来支持接受完成通知以及完成等待改进长期运行的（同步）方法。

活动对象（active object）设计模式通常使用异步方法调用，异步方法调用的一个替代方案是同步的方法调用和未来对象（future object）模式。



在Web浏览器的实现上可以采用异步方法调用，例如浏览器需要在Web页面中的图像加载完成之前将页面显示出来。


\subsection{Pattern}

在计算机科学中，参与者模式（Actor model）是一种并发运算上的模型。

“参与者”是一种程序上的抽象概念，被视为并发运算的基本单元：当一个参与者接收到一则消息，它可以做出一些决策、创建更多的参与者、发送更多的消息、决定要如何回答接下来的消息。

参与者模型推崇的哲学是“一切皆是参与者”，与面向对象编程的“一切皆是对象”类似，但是面向对象编程通常是顺序执行的，而参与者模型是并行执行的。

参与者是一个运算实体，回应接受到的消息，同时并行的：

\begin{compactitem}
\item 发送有限数量的消息给其他参与者；
\item 创建有限数量的新参与者；
\item 指定接受到下一个消息时的行为。
\end{compactitem}

以上操作不含有顺序执行的假设，因此可以并行进行。

发送者与已经发送的消息解耦是参与者模型的根本优势，这样就允许进行异步通信，同时满足消息传递的控制结构。

消息接收者是通过地址区分的，有时也被称作“邮件地址”，因此参与者只能和它拥有地址的参与者通信，它可以通过接受到的信息获取地址，或者获取它创建的参与者的地址。

参与者模型的特征是，参与者内部或之间进行并行计算，参与者可以动态创建，参与者地址包含在消息中，交互只有通过直接的异步消息通信，不限制消息到达的顺序。



\subsection{Task}



在Server程序中如果需要执行一下很耗时的操作，比如一个聊天服务器发送广播，Web服务器中发送邮件。如果直接去执行这些函数就会阻塞当前进程，导致服务器响应变慢。

与旧版本（<=2.2）的Apache不同，nginx不采用每客户机一线程的设计模型，而是充分使用异步逻辑来削减上下文调度开销，所以并发服务能力更强，可以支持大量的平行连接。

PHP-FPM自PHP-5.3.3起开始加入到了PHP核心，编译时加上\texttt{--enable-fpm}就可以提供支持，然后PHP-FPM以守护进程在后台运行，在Nginx响应请求后，自行处理静态请求，PHP请求则经过\texttt{fastcgi\_pass}交由PHP-FPM处理并在处理完毕后返回，因此Nginx和PHP-FPM的组合成为了一种稳定、高效的PHP运行方式，效率要比传统的Apache和mod\_php高出不少。

Node.js提供事件驱动和非阻塞I/O API，其设计目标是任何需要操作I/O的函数都使用回调函数，可以优化应用程序的吞吐量和规模，这些技术通常被用于实时应用程序。

libuv是一个网络和文件系统功能的抽象层，既可以用于Windows又可以用于符合POSIX标准的系统（例如Linux、OS X和Unix），同时Node.js使用libuv来处理异步事件，而且V8提供了JavaScript的实时运行环境。

\begin{lstlisting}[language=PHP]
var http = require('http');

http.createServer(function(request, response){
	response.writeHead(200,{'Content-Type': 'text/plain'});
	resposne.end('Hello World\n');
}).listen(8000);

console.log('Server running at http://127.0.0.1:8000/');
\end{lstlisting}

基于Node.js也可以实现简单的TCP服务器，并监听端口7000来输出（echo）之前输入的消息：

\begin{lstlisting}[language=PHP]
var net = require('net');

net.createServer(function (stream){
	stream.write('hello\n');
	
	stream.on('end',function(){
		stream.end('goodbye\r\n');
	});
	stream.pipe(stream);
}).listen(7000);
\end{lstlisting}

Redis数据库将全部的数据存储在内存中，并且使用快照以半持久耐用模式将数据集以异步方式从内存以RDB格式写入硬盘。

Swoole提供了异步任务处理的功能，可以投递一个异步任务到TaskWorker进程池中执行，不影响当前请求的处理速度。

基于第一个TCP服务器，只需要增加onTask和onFinish2个事件回调函数就可以实现异步任务处理。



\begin{lstlisting}[language=PHP]
//创建swoole_server对象，在127.0.0.1监听9501端口
$tcpserver = new swoole_server("127.0.0.1", 9501);

$tcpserver->set(array(
    'worker_num' => 8,   //工作进程数量
    'daemonize' => 0, //是否作为守护进程
    'task_worker_num' => 4 // 设置异步任务的工作进程数量
));

// 监听连接进入事件
$tcpserver->on('connect', function ($tcpserver, $fd){
    echo "Client:Connect.\n";
});

//监听数据发送事件
$tcpserver->on('receive', function ($tcpserver, $fd, $from_id, $data) {
    $tcpserver->send($fd, 'Swoole TCP Server: '.$data);
    // //投递异步任务
    $task_id = $tcpserver->task($data);
    echo "Dispatch AsyncTask: id = $task_id\n";
    $tcpserver->close($fd);
});

// 处理异步任务
$tcpserver->on('task',function($tcpserver,$task_id,$fram_id,$data){
	echo "New AsyncTask[id=$task_id]" . PHP_EOL;
	// 返回任务执行的结果
	$tcpserver->finish("$data-> OK");
});

// 处理异步任务的结果
$tcpserver->on('finish',function($tcpserver,$task_id,$data){
	echo "AsyncTask[$task_id] Finish: $data" . PHP_EOL;
});

//监听连接关闭事件
$tcpserver->on('close', function ($tcpserver, $fd) {
    echo "Client: Close.\n";
});

//启动服务器
$tcpserver->start();
\end{lstlisting}


另外，需要设置task进程数量，可以根据任务的耗时和任务量配置适量的task进程。


在异步处理任务过程中，调用\texttt{\$tcpserver->task()}后，程序立即返回，继续向下执行代码。onTask回调函数Task在进程池内被异步执行，执行完成后调用\texttt{\$tcpserver->finish()}返回结果。

注意，finish操作是可选的，也可以不返回任何结果。



