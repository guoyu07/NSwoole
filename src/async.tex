\part{Async}


\chapter{Overview}


计算机的通信方式包括并行（Parallel）通信和串行（Serial）通信。


\section{Serial Communication}

在远程通信和计算机科学中，串行通信（Serial communication）是指在计算机总线或其他数据通道上，每次传输一个位元数据，并连续进行以上单次过程的通信方式。

串行通信被用于长距离通信以及大多数计算机网络，在这些应用场合里，电缆和同步化使并行通信实际应用面临困难。

凭借着串行通信改善的信号完整性和传播速度，串行通信总线正在变得越来越普遍，甚至在短程距离的应用中，其优越性已经开始超越并行总线不需要串行化元件(serializer)，并解决了时钟偏移（Clock skew）、互联密度（interconnect density）等缺点。例如，PCI到PCI Express的升级就是一个串行通信的例子。

最初，如果集成电路具有更多的引脚的话，那么它的价格通常会更加昂贵。为了减少封装中的引脚数，许多集成电路在速度不是特别重要的情况下，使用串行总线来传输数据。这样的低价串行总线的例子有摩尔斯电码、以太网、MIDI、USB、IEEE 1394、PCI Express、SATA、SPI、I$^2$C、UNI/O和1-Wire等\footnote{具体来说，串行通信架构的例子包括摩尔斯电码（用于电报）、RS-232（低速，用于串行接口）、RS-422、RS-423、RS-485、I$^2$C、SPI、ARINC 818Avionics数字视频总线、通用串行总线（中速，用于连接计算机和多种外部设备）、IEEE 1394、以太网、纤维管路（高速，用于连接计算机和大容量存储器）、InfiniBand（超高速，在规模上类似于PCI接口）、MIDI数字乐器控制、DMX512舞台灯光控制、SDI-12工业传感器协议、串行SCSI、SATA、SpaceWire航天器通信网络、HyperTransport、PCI Express、同步光网络（光纤高速传输）、T-1和E-1变体（通过铜线对的高速通信）、MIL-STD-1553A/B。}。

在计算机之间、计算机内部各部分之间，通信可以以串行和并行的方式进行。一个并行连接通过多个通道（例如导线、印制电路布线和光纤）在同一时间内传播多个数据流，而一个串行在同一时间内只连接传输一个数据流。

虽然串行连接单个时钟周期能够传输的数据比并行数据更少，前者传输能力看起来比后者要弱一些，实际的情况却常常是串行通信可以比并行通信更容易提高通信时钟频率，从而提高数据的传输速率。

有以下一些因素允许串行通信具有更高的通信时钟频率：

\begin{compactitem}
\item 无需考虑不同通道的时钟脉冲相位差（clock skew）；
\item 串行连接所需的物理介质，例如电缆和光纤，少于并行通信，从而减少占用空间的体积；
\item 串扰的问题可以得到大幅度缓解。
\end{compactitem}

在许多情况里，串行通信都凭借其更低廉的部署成本成为更佳的选择，尤其是在远距离传输中，而且许多集成电路都具有串行通信接口来减少引脚数量来节约成本。





\section{Parallel Communication}

与串行通信对应的是并行通信，它在串行端口上通过一次同时传输若干位元数据的方式进行通信。

具体来说，并行通信是指8位数据同时通过并行线进行传送，这样数据传送速度大大提高，但是并行传送的线路长度受到限制，长度增加导致干扰也会增加，数据也就容易出错，因此并行通信通常用于单机。



\section{Network}

计算机科学中的异步通信（Asynchronous conferencing）特指以计算机为媒介，沟通，协作和学习，在互动贡献者中有一定延迟的技术。与之相对的是同步通信，广泛应用于各种“聊天”系统的用户“实时”同步通信。


异步传输模式（Asynchronous Transfer Mode，ATM）又叫信元中继，采用电路交换的方式，并以信元（cell）为单位。每个信元长53字节，其中报头占了5字节。

ATM能够比较理想地实现各种QoS，既能够支持有连接的业务，又能支持无连接的业务，因此成为了宽带ISDN（B-ISDN）技术的典范。

作为一种交换技术，ATM在发送数据时，先将数字数据切割成多个固定长度的数据包，之后利用光纤或DS1/ DS3发送。到达目的地后，再重新组合。

ATM网络可同时将声音、视频及数据集成在一起，从而可以针对各种信息型态提供最佳的传输环境。

HTTP/2是HTTP 1.1基于SPDY协议的更新\footnote{httpbis工作小组最初考虑了Google的SPDY协议、微软的SM协议和Network-Friendly HTTP更新，Facebook对各方案进行了评价并最终推荐了SPDY协议，HTTP 2.0的首个草稿于2012年11月发布，其内容基本和SPDY协议相同。}，其目标包括异步连接复用，头压缩和请求反馈管线化并保留与HTTP 1.1的完全语义兼容。


\subsection{Protocol}







\section{Process}


进程（process）是计算机中已运行程序的实体，也是分时系统的基本运作单位。

\begin{compactitem}
\item 在面向进程设计的系统（例如早期的UNIX，Linux 2.4及更早的版本），进程是程序的基本执行实体。
\item 在面向线程设计的系统（例如当代多数操作系统、Linux 2.6及更新的版本），进程本身不是基本运行单位，而是线程的容器。
\end{compactitem}

程序本身只是指令、数据及其组织形式的描述，如果程序没有被计算机执行，那么程序就只是硬盘上的一个文件而已，操作系统在计算机关闭后也仅仅是硬盘上的一组文件。

进程才是程序（那些指令和数据）的真正运行实例，若干进程有可能与同一个程序相关系，而且每个进程都可以以同步（循序）或异步（平行）的方式独立运行。

现代计算机系统可在同一段时间内以进程的形式将多个程序加载到存储器中，并通过时间共享（或称时分复用）来在一个处理器上表现出同时（平行性）运行的感觉。

多线程是每一个线程都代表一个进程内的一个独立执行上下文，因此使用多线程技术的操作系统或计算机架构可以让同样程序的平行线程真正同时运行在在多CPU主机或网络上（以及在不同的CPU上）。

\begin{compactitem}
\item 在批处理系统中，进程称为工作（jobs）；
\item 在分时系统中，进程称为用户程序（user progams）或任务（tasks）。
\item 在多数情况，工作与进程是同义词，但进程（process）已较为人接受。
\end{compactitem}

当用户下达运行程序的命令后，就会产生进程。同一程序可产生多个进程（一对多关系），这样就可以允许同时有多位用户运行同一程序，却不会相冲突。

进程需要一些资源才能完成工作，例如CPU使用时间、存储器、文件以及I/O设备，并且为依序逐一进行，因此每个CPU核心任何时间内仅能运行一个进程。

具体来说，一个计算机系统进程包括（或者说“拥有”）下列数据：

\begin{compactitem}
\item 那个程序的可运行机器码的一个在存储器的映像。\
\item 分配到的存储器（通常是虚拟的一个存储器区域）。存储器的内容包括可运行代码、特定于进程的数据（输入、输出）、调用堆栈、堆栈（用于保存运行时运输中途产生的数据）。
\item 分配给该进程的资源的操作系统描述符，诸如文件描述符（Unix术语）或文件句柄（Windows）、数据源和数据终端。

\item 安全特性，诸如进程拥有者和进程的权限集（可以容许的操作）。

\item 处理器状态（内文），诸如寄存器内容、物理存储器定址等。当进程正在运行时，状态通常存储在寄存器，其他情况在存储器。
\end{compactitem}

进程在运行时，状态（state）会改变，可以将进程状态理解为进程当前的动作：

\begin{compactitem}
\item 新生（new）：进程新产生中。
\item 运行（running）：正在运行。
\item 等待（waiting）：等待某事发生，例如等待用户输入完成。亦称“阻塞”（blocked）
\item 就绪（ready）：排班中，等待CPU。
\item 结束（terminated）：完成运行。
\end{compactitem}

进程的各个状态名称可能随不同操作系统而不同，例如对于单CPU系统，任何时间可能有多个进程为等待、就绪，但是必定仅有一个进程在运行。

\subsection{IPC}

IPC（Inter-Process Communication，进程间通信）指至少两个进程或线程间传送数据或信号的一些技术或方法。

最初，进程是计算机系统分配资源的最小单位（严格说来是线程），每个进程都有自己的一部分独立的系统资源，彼此是隔离的。

后来，为了能使不同的进程互相访问资源并进行协调工作，才有了进程间通信。

在一个典型的例子中，使用进程间通信的两个应用可以被分类为客户端和服务器，其中客户端进程请求数据，服务端回复客户端的数据请求。

另外，有一些应用（例如分布式计算）本身既是服务器又是客户端，这些进程可以运行在同一台计算机上或网络连接的不同计算机上。

具体来说，进程间通信技术包括消息传递、同步、共享内存和远程过程调用，而且IPC已经成为一种标准的Unix通信机制，其实现机制如下：


\begin{longtable}{|m{180pt}|m{250pt}|}
%head
\multicolumn{2}{r}{}
\tabularnewline\hline
方法&提供方（操作系统或其他环境）
\endhead
%endhead

%firsthead
\caption{主要的 IPC 方法}\\
\hline
参数名称&提供方（操作系统或其他环境）
\endfirsthead
%endfirsthead

%foot
\multicolumn{2}{r}{}
\endfoot
%endfoot

%lastfoot
\endlastfoot
%endlastfoot

\hline
文件(File)				&多数操作系统\\
\hline
信号(Signals)			&多数操作系统\\
\hline
套接字(Sockets)&多数操作系统\\
\hline
消息队列(Message queue)&多数操作系统\\
\hline
管道(Pipeline)			&所有的 POSIX 系统, Windows\\
\hline
命名管道()			&所有的 POSIX 系统, Windows\\
\hline
信号量（Semaphore）	&所有的 POSIX 系统, Windows\\
\hline
共享内存（Shared Memory）&所有的 POSIX 系统, Windows\\
\hline
消息传递（Message passing，不共享）&用于 MPI规范，Java RMI, CORBA, MSMQ, MailSlot 以及其他\\
\hline
内存映射文件（Memory-mapped file）&所有的 POSIX 系统, Windows\\
\hline
\end{longtable}



进程间通信可以实现信息共享，例如Web服务器中通过浏览器使用进程间通信来共享Web文件（网页等）和多媒体。

进程间通信可以加速数据处理，例如维基百科使用通过进程间通信进行交流的多服务器来满足用户的请求。

进程间通信还可以实现模块化和私有权分离。

不过，与直接共享内存地址空间的多线程技术相比，进程间通信需要采用某种形式的内核开销，导致降低性能。

最后，几乎大部分IPC都不是程序设计的自然扩展，往往戏剧性增加了程序复杂度。







\section{Thread}

线程（thread）是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位。

一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。

在Unix System V及SunOS中，线程也被称为轻量进程（lightweight processes），但是实际上轻量进程更多指内核线程（kernel thread），而把用户线程（user thread）称为线程。

作为独立调度和分派的基本单位，线程可以操作系统内核调度的内核线程（例如Win32线程），由用户进程自行调度的用户线程（例如Linux平台的POSIX Thread），或者由内核与用户进程（例如Windows 7的线程）等，进行混合调度。

同一进程中的多条线程将共享该进程中的全部系统资源，例如虚拟地址空间，文件描述符和信号处理等，但是同一进程中的多个线程有各自的调用栈（call stack），自己的寄存器环境（register context），自己的线程本地存储（thread-local storage）。



一个进程可以有很多线程，每条线程并行执行不同的任务。

在多核或多CPU，或支持Hyper-threading的CPU上使用多线程程序设计的好处是显而易见，即提高了程序的执行吞吐率。

在单CPU单核的计算机上，使用多线程技术，也可以把进程中负责IO处理、人机交互而常备阻塞的部分与密集计算的部分分开来执行，编写专门的workhorse线程执行密集计算，从而提高了程序的执行效率。

与进程的状态不同，线程有四种基本状态，分别为：

\begin{compactitem}
\item 产生（spawn）
\item 中断（block）
\item 非中断（unblock）
\item 结束（finish）
\end{compactitem}

\subsection{UNIX  International}

SUN Solaris操作系统使用的线程叫做UNIX International线程，支持内核线程、轻权进程和用户线程。

一个进程可有大量用户线程，大量用户线程复用少量的轻权进程，轻权进程与内核线程一一对应。用户级线程在调用核心服务时（如文件读写），需要“捆绑（bound）”在一个lwp上。

\begin{compactitem}
\item 永久捆绑（一个LWP固定被一个用户级线程占用，该LWP移到LWP池之外）；
\item 临时捆绑（从LWP池中临时分配一个未被占用的LWP）
\end{compactitem}

在调用系统服务时，如果所有LWP已被其他用户级线程所占用（捆绑），则该线程阻塞直到有可用的LWP。如果LWP执行系统线程时阻塞（如read()调用），则当前捆绑在LWP上的用户级线程也阻塞。

UNIX International线程的头文件是<thread.h>。

\begin{compactitem}
\item 创建用户级线程

\begin{lstlisting}[language=PHP]
int thr_create(void * stack_base, size_t stack_size, void *(*start_routine，void *), void * arg, long flags, thread_t * new_thr);
\end{lstlisting}

其中flags包括：THR\_BOUND（永久捆绑）, THR\_NEW\_LWP（创建新LWP放入LWP池），若两者同时指定则创建两个新LWP，一个永久捆绑而另一个放入LWP池。

\item 等待用户级线程

\begin{lstlisting}[language=PHP]
int thr_join(thread_t wait_for, thread_t *dead, void **status);
\end{lstlisting}

\item 挂起用户级线程

\begin{lstlisting}[language=PHP]
int thr_suspend(thread_t thr);
\end{lstlisting}

\item 继续用户级线程

\begin{lstlisting}[language=PHP]
int thr_continue(thread_t thr);
\end{lstlisting}

\item 退出用户级线程

\begin{lstlisting}[language=PHP]
void thr_exit(void *status);
\end{lstlisting}

\item 返回当前用户级线程的线程标识符

\begin{lstlisting}[language=PHP]
thread_t thr_self( void );
\end{lstlisting}

\end{compactitem}

\subsection{POSIX Thread}

POSIX线程（POSIX threads），简称Pthreads，是线程的POSIX标准。该标准定义了创建和操纵线程的一整套API。


在类Unix操作系统（Unix、Linux、Mac OS X等）中，都使用Pthreads作为操作系统的线程，Windows操作系统也有其移植版pthreads-win32。

Pthreads定义了一套C语言的类型、函数与常量，它以pthread.h头文件和一个线程库实现。

Pthreads API中大致共有100个函数调用，全都以"pthread\_"开头，并可以分为四类：

\begin{compactitem}
\item 线程管理，例如创建线程，等待(join)线程，查询线程状态等。
\item Mutex：创建、摧毁、锁定、解锁、设置属性等操作
\item 条件变量（Condition Variable）：创建、摧毁、等待、通知、设置与查询属性等操作
\item 使用了读写锁的线程间的同步管理
\end{compactitem}

POSIX的Semaphore API可以和Pthreads协同工作，但这并不是Pthreads的标准，因而这部分API是以\texttt{"sem\_"}打头，而非\texttt{"pthread\_"}。



\begin{compactitem}
\item 创建用户级线程

\begin{lstlisting}[language=PHP]
int pthread_create(pthread_t * thread, const pthread_attr_t * attr, void *(*start_routine)(void *), void *arg);
\end{lstlisting}

\item 等待用户级线程

\begin{lstlisting}[language=PHP]
int pthread_join(pthread_t thread, void ** retval);
\end{lstlisting}

\item 退出用户级线程

\begin{lstlisting}[language=PHP]
void pthread_exit(void *retval);
\end{lstlisting}

\item 返回当前用户级线程的线程标识符

\begin{lstlisting}[language=PHP]
pthread_t pthread_self(void);
\end{lstlisting}

\item 用户级线程的取消

\begin{lstlisting}[language=PHP]
int pthread_cancel(pthread_t thread);
\end{lstlisting}

\end{compactitem}


\subsection{Win32 Thread}

Win32线程是Windows API的一部分，其上下文包括寄存器、核心栈、线程环境块和用户栈。

Win32线程的头文件是<Windows.h>，仅适用于Windows操作系统。



\begin{compactitem}
\item 创建用户级线程

\begin{lstlisting}[language=PHP]
HANDLE WINAPI CreateThread(LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId);
\end{lstlisting}

\item 结束本线程

\begin{lstlisting}[language=PHP]
VOID WINAPI ExitThread(DWORD dwExitCode);
\end{lstlisting}



\item 挂起指定的线程

\begin{lstlisting}[language=PHP]
DWORD WINAPI SuspendThread( HANDLE hThread );
\end{lstlisting}

\item 恢复指定线程运行

\begin{lstlisting}[language=PHP]
DWORD WINAPI ResumeThread(HANDLE hThread);
\end{lstlisting}



\item 等待线程运行完毕

\begin{lstlisting}[language=PHP]
DWORD WINAPI WaitForSingleObject(HANDLE hHandle, DWORD dwMilliseconds);
\end{lstlisting}

\item 返回当前线程的线程标识符

\begin{lstlisting}[language=PHP]
DWORD WINAPI GetCurrentThreadId(void);
\end{lstlisting}

\item 返回当前线程的线程句柄

\begin{lstlisting}[language=PHP]
HANDLE WINAPI GetCurrentThread(void);
\end{lstlisting}

\end{compactitem}

\subsection{C++11 Thread}

2011年8月12日，国际标准化组织（ISO）发布了第三个C++标准，即ISO/IEC 14882:2011，简称ISO C++ 11标准。该标准第一次把线程的概念引入C++标准库。Windows平台运行的VS2012和Linux平台运行的g++4.7，都完美支持C++11线程。

C++ 11线程的头文件是<thread>

\begin{compactitem}
\item 创建线程

\begin{lstlisting}[language=PHP]
std::thread::thread(Function&& f, Args&&... args);
\end{lstlisting}

\item 等待线程结束

\begin{lstlisting}[language=PHP]
std::thread::join();
\end{lstlisting}

\item 脱离线程控制

\begin{lstlisting}[language=PHP]
std::thread::detach();
\end{lstlisting}


\item 交换线程

\begin{lstlisting}[language=PHP]
std::thread::swap(thread& other);
\end{lstlisting}
\end{compactitem}


\subsection{C11 Thread}


2011年12月8日，国际标准化组织（ISO）发布了第三个C语言标准，即ISO 9899:2011，简称ISO C 11标准。该标准第一次把线程的概念引入C语言标准库。

C11线程仅仅是个“建议标准”，也就是说100\%遵守C11标准的C编译器是可以不支持C11线程的。根据C11标准的规定，只要编译器预定义了\_\_STDC\_NO\_THREADS\_\_宏，就可以没有<threads.h>头文件，自然也就也没有下列函数。

C11线程的头文件是<threads.h>

\begin{compactitem}
\item 创建线程

\begin{lstlisting}[language=PHP]
int thrd_create(thrd_t *thr, thrd_start_t func, void *arg);
\end{lstlisting}


\item 结束本线程

\begin{lstlisting}[language=PHP]
_Noreturn void thrd_exit( int res );
\end{lstlisting}

\item 等待线程运行完毕

\begin{lstlisting}[language=PHP]
int thrd_join(thrd_t thr, int *res);
\end{lstlisting}

\item 返回当前线程的线程标识符

\begin{lstlisting}[language=PHP]
thrd_t thrd_current();
\end{lstlisting}
\end{compactitem}

\subsection{Java Thread}

\begin{compactitem}
\item 最简单的情况是，Thread/Runnable的run()方法运行完毕，自行终止。
\item 对于更复杂的情况，比如有循环，则可以增加终止标记变量和任务终止的检查点。
\item 最常见的情况，也是为了解决阻塞不能执行检查点的问题，用中断来结束线程，但中断只是请求，并不能完全保证线程被终止，需要执行线程协同处理。
\item IO阻塞和等锁情况下需要通过特殊方式进行处理。
\item 使用Future类的cancel()方法调用。
\item 调用线程池执行器的shutdown()和shutdownNow()方法。
\item 守护线程会在非守护线程都结束时自动终止。
\item Thread有stop()方法，但已不推荐使用。
\end{compactitem}


\subsection{Multi Thread}

多线程（multithreading）是指从软件或者硬件上实现多个线程并发执行的技术。

具有多线程能力的计算机因有硬件支持而能够在同一时间执行多于一个线程，进而提升整体处理性能，具有多线程能力的系统包括对称多处理机、多核心处理器以及芯片级多处理（Chip-level multithreading）或同时多线程（Simultaneous multithreading）处理器。

程序代码中存在的数据及控制依赖关系使得单线程中所能发掘的指令并行潜力是有限的，因此为了发掘有限的指令级并行潜力而一味强化乱序执行和分支预测，以至于处理器复杂度和功耗急剧上升，有时候是得不偿失的。

现代微处理器多采用硬件多线程技术来发掘线程之间的线程级并行潜力，这样就允许在接口转换的专业领域运算能力大幅提升。

\begin{compactitem}
\item 既使这样做对于提升单一程序或是线程的性能相当困难，但是目前多数的系统都是使用多任务的方式作业。
\item 能够明显的提升整体系统运算能力，总体吞吐量获得提升。
\end{compactitem}



即便处理器只能运行一个线程，操作系统也可以通过快速的在不同线程之间进行切换，由于时间间隔很小，来给用户造成一种多个线程同时运行的假象。这样的程序运行机制被称为软件多线程。例如，微软的Windows作业系统和Linux就是在各个不同的执行绪间来回切换，被称为单用户多任务作业系统，但是DOS这类文字接口作业系统在一个时间只能处理一项工作，因此被视为单用户单任务系统。

除此之外，许多系统及处理器也支持硬件多线程技术。例如，对称多处理机（SMP）系统具有多个处理器，所以具有真正的同时执行多个线程的能力，CMP技术通过在一块芯片上集成多个核心（Core）也具有真正的多线程能力。

CMT技术则稍有不同，有的是依靠硬件执行线程切换来获得多线程能力，操作系统不再负责线程切换，因而这部分开销可以减少甚至消除，这方面典型的例子是Sun的UltraSPARC T1，它同时综合了CMP和CMT，微软的Windows 2000以后的操作系统皆支持多线程与超线程技术。

对于现在的两种提升运算能力的主要技术多进程和多线程，当共享硬件资源（例如缓存或是TLB）时多线程会造成干预，而且单线程的运行时间可能不会因为多线程而变短，不过硬件侦测技术有可能改变这一状况。

多线程的硬件支持会牵涉到软件支持，如此程序与操作系统就需要比多过程化更大幅度的修改。

在粗粒度交替多线程系统中，一个线程持续运行直到该线程被一个事件挡住而制造出长时间的延迟(可能是内存load/store操作，或者程序分支操作)。该延迟通常是因缓存失败而从核心外的内存读写，而这动作会使用到几百个CPU周期才能将数据回传。与其要等待延迟的时间，线程化处理器会切换运行到另一个已就绪的线程。只要当之前线程中的数据送达后，上一个线程就会变成已就绪的线程。这种方法来自各个线程的指令交替执行，可以有效的掩盖内存访问时延，填补流水线空洞。

举例来说：

\begin{compactenum}
\item 周期 i ：接收线程 A 的指令 j
\item 周期 i+1：接收线程 A 的指令 j+1
\item 周期 i+2：接收线程 A 的指令 j+2，而这指令缓存失败
\item 周期 i+3：线程调度器介入，切换到线程 B
\item 周期 i+4：接收线程 B 的指令 k
\item 周期 i+5：接收线程 B 的指令 k+1
\end{compactenum}

在概念上，粗粒度交替多线程系统与实时操作系统中使用的合作式多任务类似，在该任务需要为一个事件等待一段时间的时候会主动放弃运行时段。

粗粒度交替多线程系统的硬件支持的目标是允许在挡住的线程与已就绪的线程中快速切换。为了要达成这个目标，硬件成本将复制程序看得见的寄存器与一些处理器控制寄存器（像是程序计算器）。从一个线程切换到另一个线程对硬件来讲意谓著从一个寄存器复制到另一个。

\begin{compactitem}
\item 线程切换能够在一个 CPU 周期内完成(实际上可以没有开销，上个周期在运行线程A，下个周期就已在运行线程B)。
\item 每个线程是独自运行的，没有其他线程与目前共享硬件资源。对操作系统来说，通常每个虚拟线程都被视做一个处理器。这样就不需要很大的软件变更（像是特别写支持多线程的操作系统）。
\end{compactitem}

为了要在各个现行中的线程有效率的切换，每个现行中的线程需要有自己的暂存设置（register set）。像是为了能在两个线程中快速切换，硬件的寄存器需要两次例示（instantiated）。

许多微控制器与嵌入式处理器有多重的寄存器列，就能够在中断时快速环境切换，这样架构可以视为程序的线程与中断线程之间的块状多线程处理。


细粒度交替式多线程系统提供了更高性能的多线程做法，所有 CPU 周期轮流切换至不同的线程，来自各线程的指令按顺序交替执行，整个执行过程很像桶形处理器(Barrel Processor)。

\begin{compactenum}
\item 周期 i ：接收线程 A 的一个指令
\item 周期 i+1：接收线程 B 的一个指令
\item 周期 i+2：接收线程 C 的一个指令
\end{compactenum}

细粒度交替式多线程的效果是会将所有从运行管线中的数据从属（data dependency）关系移除掉。因为每个线程是相对独立，管线中的一个指令层次结构需要从已跑完管线中的较旧指令代入输出的机会就相对的变小了。

在概念上，细粒度交替式多线程与操作系统的核心先占多任务（pre-exemptive multitasking）相似。

除了讨论块状多线程的硬件成本，交错式多线程也因每层管线需要追踪运行中指令的线程代码而增加硬件成本。而且，当越来越多的线程同时在管线中运行，像是缓存与 TLB 等共享资源也要加大来避免不同线程之间的冲突。

目前，最先进的多线程技术是应用在超标量处理器上的同步多线程，超标量处理器内在每个CPU周期中，单独一个线程会发布众多的指令。应用同步多线程(SMT)之后，超标量处理器就可以在每个CPU周期中，从多个线程中发布指令。辨识到任何一个单一线程拥有有限数量的指令平行处理，这种类型的多线程是试着利用并行的方式跨越多线程，以减少浪费与闲置的资源。 举例来说：

\begin{compactenum}
\item 周期 i：线程 A 的 j 指令 与 j+1 指令，还有 B 线程的指令 k 同时发布
\item 周期 i+1：线程 A 的 j+2 指令、线程 B 的 k+1指令，与线程 C 的 m 指令同时发布
\item 周期 i+2：线程 A 的 j+3 指令，与线程 C 的 m+1 与 m+2 指令同时发布
\end{compactenum}

交错式多线程如果不计硬件成本，SMT在每个管线层次结构的追踪线程指令会有多余的花费，而且缓存与TLB等共享的资源可能会因为多出来的线程而变得更大。


在大多数研究领域内是要求线程调度器要能够快速选择其中一个已就绪线程去运行，而不是一个一个运行而降低效率。所以要让调度器去分辨线程的优先级是很重要的。而线程调度器可能是以硬件、软件，或是软硬件并存的形式存在。

另一个研究领域则是要研究何种事件（缓存失败、内部运行续连系、使用DMA等）会造成线程切换。

如果多线程的方案会复制所有软件可见的状态，包括特许的控制登录、TLB 等，那就能够让虚拟机去创造各式线程，这样就允许在相同的处理器中每个线程跑各自的操作系统。换句话说，如果只有存储了用户模式的状态，就能够让相同的裸晶大小的芯片在一段时间内处理更多的线程。

\subsection{Thread Pool}

线程池（Thread Pool）是一种成熟的线程使用模式， 实现有领导者与跟随者模式和半同步半异步模式。

线程池的伸缩性对性能有较大的影响。

\begin{compactitem}
\item 创建太多线程，将会浪费一定的资源，有些线程未被充分使用。
\item 销毁太多线程，将导致之后浪费时间再次创建它们。
\item 创建线程太慢，将会导致长时间的等待，性能变差。
\item 销毁线程太慢，导致其它线程资源饥饿。
\end{compactitem}

\section{Interrupt}

在计算机科学中，中断（Interrupt）是指处理器接收到来自硬件或软件的信号，提示发生了某个事件，应该被注意，这种情况就称为中断。

通常，在接收到来自外围硬件（相对于中央处理器和内存）的异步信号，或来自软件的同步信号之后，处理器将会进行相应的硬件/软件处理。发出这样的信号称为进行中断请求（interrupt request，IRQ）。

\begin{compactitem}
\item 硬件中断导致处理器通过一个运行信息切换（context switch）来保存执行状态（以程序计数器和程序状态字等寄存器信息为主）。

\begin{compactenum}
\item 可屏蔽中断（maskable interrupt）。硬件中断的一类，可通过在中断屏蔽寄存器中设定位掩码来关闭。
\item 非可屏蔽中断（non-maskable interrupt，NMI）。硬件中断的一类，无法通过在中断屏蔽寄存器中设定位掩码来关闭。典型例子是时钟中断（一个硬件时钟以恒定频率—如50Hz—发出的中断）。
\item 处理器间中断（interprocessor interrupt）。一种特殊的硬件中断。由处理器发出，被其它处理器接收。仅见于多处理器系统，以便于处理器间通信或同步。
\item 伪中断（spurious interrupt）。一类不希望被产生的硬件中断。发生的原因有很多种，如中断线路上电气信号异常，或是中断请求设备本身有问题。
\end{compactenum}

\item 软件中断则通常作为CPU指令集中的一个指令，以可编程的方式直接指示这种运行信息切换，并将处理导向一段中断处理代码。

\begin{compactenum}
\item 软件中断。是一条CPU指令，用以自陷一个中断。由于软中断指令通常要运行一个切换CPU至内核态（Kernel Mode/Ring 0）的子例程，它常被用作实现系统调用（System call）。
\end{compactenum}

\end{compactitem}

处理器通常含有一个内部中断屏蔽位，并允许通过软件来设定。一旦被设定，所有外部中断都将被系统忽略。这个屏蔽位的访问速度显然快于中断控制器上的中断屏蔽寄存器，因此可提供更快速地中断屏蔽控制。

如果一个中断使得机器处于一种确定状态，则称为精确中断（precise interrupt）。精确中断须保证：

\begin{compactitem}
\item 程序计数器的值被保存在已知位置。
\item 程序计数器所指向的指令之前的所有指令已被执行完毕。
\item 程序计数器所指向的指令之后的所有指令不可被执行。

如果中断信号到来后而转入处理前发生了任何针对寄存器/内存的更改，都必须予以还原。
\item 程序计数器所指向的指令地执行状态已知。
\end{compactitem}


如果无法满足以上条件，此中断被称作非精确中断（imprecise interrupt）。

中断在计算机多任务处理（尤其是实时系统）中特别有用，这样的系统（包括运行于其上的操作系统）也被称为“中断驱动的”（interrupt-driven）。


中断的典型应用包括系统时钟、磁盘输入输出操作、断电信号以及软件自陷等。‘

\begin{compactitem}
\item 系统时钟通过一个计数器（多基于某种振动频率）定期向CPU发出中断，CPU通过专门的时钟中断处理程序来保持计时。现代操作系统对系统时钟的另一个主要应用是为进程切换提供时机。一旦时钟中断发生，程序计数器会被自动压栈，而此时操作系统就有机会将程序状态及内存映像转存至别处，并调用进程调度程序来选择下一个进程，并将其进程状态，包括程序计数器，导入寄存器。这样下一个程序就可以运行。应注意进程调度程序的调度时机不止于时钟中断。
\item 磁盘中断标识某个磁盘设备完成了数据的发送／接收。磁盘中断发生后，等待这个中断的进程可以（但未必，这取决于进程调度程序当时的判断）继续执行。
\item 断电中断指示计算机能源即将丧失，计算机可以相应中断程序作有序的关机处理。
\end{compactitem}

INTEL公司于20世纪70年代末推出的16位处理器8086A在中断处理上引入的特色为后续INTEL处理器所共有。

\begin{compactitem}
\item pin（引脚）

8086A提供两个中断引脚：第17引脚NMI和第18引脚INTR，其中的前者用于接收非可屏蔽中断，后者则接收可屏蔽中断。

通常情况下，INTR引脚与中断控制器（如8259A）相连，后者再分别与各设备的中断请求引脚连接。

除了INTR外，8086A还将自身的16位地址总线（配合M/IO引脚并通过译码器）及8位数据总线与8259A连接，并将INTA引脚与8259A的同名引脚相连。

\item interrupt vector table（中断矢量表）

在存储器地址空间中，规定最低的1K空间（即00000H到003FFH）为中断矢量表。

全表共含256个中断矢量，每个矢量的长度为4字节，包含中断处理程序的起始地址。共有从0到255共256个中断类型码，每个中断类型码对应的中断矢量所在地址为该类型码乘以4。

举例来说，如果中断类型码为1，则对应中断矢量所在地址为00004H；如果中断类型码为33，则对应中断矢量所在地址为00084H。这样，如果已知一个中断类型码，则需要通过两次地址转换（中断类型码到中断矢量表地址；中断矢量表地址到中断处理程序地址）才能到达中断处理程序。

另外，应该注意每一个中断矢量所包含的地址是以低二字节存储偏移量，高二字节存储段地址的形式存储目标地址值的。

在全部256个中断中，前32个（0-31）为硬件系统所预留。后224个可由用户设定。在初始化8259A时，可设定其上各中断引脚（共8条）对应的中断类型码。同时，将对应此中断之处理程序的起始地址保存在该中断类型码乘4的地址位中，作为中断矢量。

在INTEL后续的32位CPU中，使用中断描述符表来代替中断矢量表。中断描述符表的起始地址由中断描述符表寄存器（IDTR）来定位，因此不再限于底部1K位置。另一方面，中断描述符表的每一个项目——称作门描述符——除了含有中断处理程序地址信息外，还包括许多属性/类型位。

门描述符分为三类：任务门、中断门和自陷门，CPU对不同的门有不同的调用（处理）方式。

\end{compactitem}

在实际运行中，一旦设备通过某引脚N向8259A发出中断指令，后者便向8086A的INTR引脚发送中断信号。8086A通过INTA引脚通知8259A中断有效（这个过程实际上还包括对此8259A的选址），后者即通过地址总线将对应引脚N的中断类型码（已预先存好，见上节）发送给CPU。CPU得到中断类型码后，先进行现场保护，主要包括：

\begin{compactenum}
\item 状态寄存器FLAGS压栈（同时堆栈寄存器SP-2）；
\item 关闭中断（将FLAGS寄存器的IF位置零）；
\item 将当前代码段寄存器CS和程序计数器IP压栈（同时堆栈寄存器SP-4）。
\end{compactenum}

现场保护完成后，CPU开始按照前述的两步骤翻译中断程序入口地址。在得到中断处理程序地址之后但调用中断处理程序之前，CPU会再检查一下NMI引脚是否有信号，以防在刚才的处理过程中忽略了可能的NMI中断。NMI的优先级始终高于INTR。

中断处理程序虽然是由程序员编写，但须循一定规范。作为例程，中断处理程序应该先将各寄存器信息（除了IP和CS，此二寄存器现已指向当前中断程序）压入堆栈予以保存，这样才能在中断处理程序内部使用这些寄存器。在程序结束时，应该按与压栈保护时相反的顺序弹出各寄存器的值。中断程序的最后一句始终是IRET指令，这条指令将栈顶6个字节分别弹出并存入IP、CS和FLAGS寄存器，完成了现场的还原。

当然，如果是操作系统的中断处理程序，则未必——通常不会——还原中断前的状态。这样的中断处理程序通常会在调用完寄存器保存例程后，调用进程调度程序（多由高级语言编写），并决定下一个运行的进程。随后将此进程的寄存器信息（上次中断时保存下来的）存入寄存器并返回。在中断程序结束之后，主程序也发生了改变。

一些与中断控制相关的指令包括：

\begin{compactenum}
\item \texttt{CLI} 关闭中断（实为将FLAGS的IF位置0）。
\item \texttt{STI} 开启中断（实为将FLAGS的IF位置1）。
\item \texttt{INT n} 调用中断子程序，n为中断类型码。DOS系统有一个系统调用API即为\texttt{INT 21H}。
\item \texttt{INT0} 先判别FLAGS的OF位是否为1，如是则直接调用类型为4的中断子程序，用以处理溢出中断。
\item \texttt{IRET} 将栈顶6个字节分别弹出并存入IP、CS和FLAGS寄存器，用以返回中断现场。
\end{compactenum}





\subsection{Level-triggered}


在依状态触发的中断系统中，一个等待响应的中断会在中断请求线路上以特定的电平标识，如高电平（1）或低电平（0）。当一个设备希望发送中断信号时，它驱动中断请求线路至相应的电平，并在CPU发出强制停止命令或处理所请求的中断事件之前始终保持。

一般而言，处理器在总线周期的特定时点响应中断的输出/ 输入。如果在某次采样时刻中断尚未被激活，则在下一次采样前，处理器都不会认为有中断发生。可以应用这个特性，避免响应在噪音较高的线路上出现的伪中断。

中断设备可被设计成与其他设备共享一条状态触发中断线路。中断线路应该包含一个特定的升／降压电阻，用于在无中断请求时为线路电平复位。中断设备在请求中断时会保持中断线路为有效电平，而没有请求中断时则令该线路置空。只要有一个或以上的设备发出中断信号，线路都会处于有效的电平。

由于可共享线路的便利，一些应用倾向于使用该类中断。当CPU检测到中断线路被断言后，就会逐一检查各共享设备，直至发现请求设备并处理之。当处理完毕后，继续检查中断线路，倘中断线路仍为有效电平则重复之前的步骤。在检查中断设备的顺序上也可做一定规划，比如优先检查那些频繁请求中断的设备，以加快中断处理，改善系统性能。

此类中断模式也有严重问题。只要还有任何设备的中断请求未被处理，线路就会一直保持有效电平状态，而这将导致CPU没有机会去探查其他设备所发生的状态变化。推迟服务低优先级设备也不可行，因为这会防止对高优先级设备的探查。倘若在线路上有一个设备持续发送请求而CPU不知道怎样对其进行服务，则这个设备就会持久并排他地占有中断线路。

早期的PCI（外设互连标准）标准出于上述效率层面的理由规定其周边须使用状态触发中断。

\subsection{Edge-triggered}

在依边沿触发的中断系统中，中断设备通过向中断线路发送一个脉冲来表示其中断请求。脉冲可以为上升沿或下降沿。在发送完脉冲后设备立即释放中断线路。如果这个脉冲太短，以至于I/O轮询不足以确保知悉其存在，则有必要使用专门的硬件设备来辅助对边沿触发的探查。

中断设备可被设计成与其他设备共享一条边沿触发中断线路。中断线路应该包含一个特定的上拉／下拉电阻，用于在无中断请求时为线路电平复位。设备通过发送一个脉冲作为其中断信号。如果多个设备在近乎相同的时间内发送脉冲，则会在线路上合并成一个信号。为防止中断丢失，CPU必须在一个脉冲之后的下一个边沿（如果脉冲为上升沿则其下一个边沿就是下降沿）立即触发。收到中断请求后CPU立即查询各中断设备以定位中断源。

边沿触发中断不会遭受状态触发中断在共享中断引脚时所遇到的问题。低优先级设备的服务可被任意推迟，而高优先级设备的中断请求仍会被CPU收到。一个即便是频繁发生的伪中断也不会影响正常设备的中断请求。但是，边沿触发中断容易丢失，特别是当中断被有意屏蔽时。在不引入锁存器的情况下，在屏蔽时段发送的中断信号不可能被恢复。在早期的计算机系统中因为中断丢失而导致处理不能继续的情况时有发生。现代中断硬件多包含有一个或一组中断状态锁存器，用以暂存一逝而过的中断请求。在对边沿触发中断硬件进行编程时，应检查这些中断状态寄存器以确保请求事件不会丢失。

已经过时的ISA（工业标准架构）标准使用边沿触发中断，但不规定其实现必须能够共享线路。


\subsection{Hybrid}


一些系统使用状态触发与边沿触发兼顾的混合中断模式。其硬件不但探测脉冲，也验证中断信号是否保持一段时间。

非可屏蔽中断多使用混合模式。由于非可屏蔽中断多与重要的系统异常事件相关，十分有必要确保对其中断信号的捕捉快速而正确。这种两步骤探查方式能够有效减轻错误中断或遗失中断给系统带来的影响。


\subsection{Message-signaled}


消息信号式中断并不直接通过对特定物理线路进行断言／发送脉冲来通知一个中断。这类中断设备通过在某种通讯媒介（一般是计算机总线）上发送一个有逻辑含义的消息（一串／排比特码）来实现中断请求。中断消息可以是通讯总线协议中专门为中断预留的类型，也可以是一个现有的类型，如内存写操作。

消息信号式中断在行为上与边沿触发中断类似，因为它们都是发送一个瞬间的信号。中断处理软件的对此类中断的处理方式也类似于边沿触发中断：如果两个消息相同，则可以合并。消息信号中断矢量（中断处理程序的地址）也可以共享，就如同物理线路可以被共享一般。

由于中断消息的识别基于特定的比特码序列而不是物理线路上的单个信号，可以有效地通过设定不同的中断比特码来划分和处理不同类型的中断。另外，使用串行或并行总线都可以传递中断消息。

由于无论状态触发还是边沿触发都在使用共享线路时存在线路竞争问题，而物理线路数本身也是稀缺资源，不可能被各中断源分别独占，所以消息信号中断是一个解决此问题的较好替代方案。消息信号中断的本质差别在于其中断请求运行在单纯的物理线路之上，具有特定的逻辑含义。这种区别好比计算机网络体系中第一层（物理层）和第二层（链路层）的差别。使用具有逻辑含义的中断请求，可以把诸请求区分开来，形成多条虚通路，而运行于一条物理总线之上。

PCI Express串行总线标准即使用消息信号模式的中断。

\subsection{Doorbell}







\section{Polling}


尽管中断可以提高计算机处理性能，但是过于密集的中断请求/响应反而会影响系统性能，这类情形被称作中断风暴（interrupt storm），与中断处理相对的是轮询（Polling）。




轮询（Polling）是一种CPU决策如何提供周边设备服务的方式，又称“程控输出入”（Programmed I/O），其过程是由CPU定时发出询问，依序询问每一个周边设备是否需要其服务，有即给予服务，服务结束后再问下一个周边，接着不断周而复始，问题是虽然轮询法实现容易，但是效率偏低。

中断是用以提高计算机工作效率、增强计算机功能的一项重要技术。最初引入硬件中断，只是出于性能上的考量。如果计算机系统没有中断，则处理器与外部设备通信时，它必须在向该设备发出指令后进行忙等待(Busy waiting)，反复轮询该设备是否完成了动作并返回结果，从而造成了大量处理器周期被浪费。

引入中断以后，当处理器发出设备请求后就可以立即返回以处理其他任务，而当设备完成动作后，发送中断信号给处理器，后者就可以再回过头获取处理结果。这样，在设备进行处理的周期内，处理器可以执行其他一些有意义的工作，而只付出一些很小的切换所引发的时间代价。后来被用于CPU外部与内部紧急事件的处理、机器故障的处理、时间控制等多个方面，并产生通过软件方式进入中断处理（软中断）的概念。

在硬件实现上，中断可以是一个包含控制线路的独立系统，也可以被集成进存储器子系统中。对于前者，在IBM个人机上，广泛使用可编程中断控制器（Programmable Interrupt Controller，PIC）来负责中断响应和处理。PIC被连接在若干中断请求设备和处理器的中断引脚之间，从而实现对处理器中断请求线路（多为一针或两针）的复用。

作为另一种中断实现的形式，即存储器子系统实现方式，可以将中断端口映射到存储器的地址空间，这样对特定存储器地址的访问实际上是中断请求。





\section{Signal}

在计算机科学中，信号（Signals）是Unix、类Unix以及其他POSIX兼容的操作系统中进程间通讯的一种有限制的方式。

信号是一种异步的通知机制，用来提醒进程一个事件已经发生。当一个信号发送给一个进程，操作系统中断了进程正常的控制流程，此时，任何非原子操作都将被中断。如果进程定义了信号的处理函数，那么它将被执行，否则就执行默认的处理函数。

在一个运行的程序的控制终端键入特定的组合键可以向它发送某些信号：

\begin{compactitem}
\item Ctrl-C发送INT信号（SIGINT）：默认情况下，这会导致进程终止。
\item Ctrl-Z发送TSTP信号（SIGTSTP）：默认情况下，这会导致进程挂起。
\item Ctrl-\textbackslash 发送QUIT信号（SIGQUIT）：默认情况下，这会导致进程终止并且将内存中的信息转储到硬盘（核心转储）。
\item 这些组合键可以通过stty命令来修改。
\end{compactitem}

kill()系统调用会在权限允许的情况下向进程发送特定的信号，类似地kill命令允许用户向进程发送信号，raise(3)库函数可以将特定信号发送给当前进程。

另外，除数为零、段错误等异常也会产生信号（这里分别是SIGFPE和SIGSEGV，默认都会导致进程终止和核心转储）。

内核可以向进程发送信号以告知它一个事件发生了。例如，当进程将数据写入一个已经被关闭的渠道是将会收到SIGPIPE信号，默认情况下会使进程关闭。

信号处理函数可以通过signal()系统调用来设置。如果没有为一个信号设置对应的处理函数，就会使用默认的处理函数，否则信号就被进程截获并调用相应的处理函数。

在没有处理函数的情况下，程序可以指定两种行为：忽略这个信号（SIG\_IGN）或者用默认的处理函数（SIG\_DFL），但是有两个信号是无法被截获并处理的：SIGKILL和SIGSTOP。

竞态条件的存在和信号本身的异步特性使信号的处理有弱点，所以在处理一个信号的过程中，进程可能收到另一个信号（甚至是相同的信号）。

sigprocmask()系统调用可以用来阻塞和恢复信号的传递，信号可以造成进程中系统调用的中断，并在信号处理完后重新开始未完成的系统调用。

在实践中，信号处理函数应该没有任何不想要的副作用，比如errno的改变、信号掩码的改变、信号处理方法的改变，以及其他全局进程性质的改变。在信号处理函数内使用不可重入函数（例如malloc和printf）也是不安全的。

进程的运行也可能导致硬件异常，例如，在类Unix系统中将一个数除以零，或者出现TLB不命中都会自动运行内核的异常处理程序。

对于某些异常如页缺失，内核有足够的信息来处理完并恢复进程的运行。但是对于另外一些异常，内核不能处理而只能通过发送信号把异常交给进程自己处理。例如，在x86架构的CPU上，如果一个进程尝试将一个数除以零，将会产生divide error异常，并使内核向出错的进程发送SIGFPE信号。相似地，如果一个进程尝试访问虚拟地址空间以外的内存，内核将向进程发送SIGSEGV信号。异常与信号的具体对应关系在不同的CPU架构上是不同的。



\section{Queue}


\subsection{Message Passing}

在计算机科学中，消息传递（Message passing）是一种通讯的形式，其主要的数学模型为参与者模式、π-calculus，并且应用在并发计算、并行计算、面向对象程序设计与进程间通讯中，进程或对象以发送及接收消息的方式来达成同步。

不同于传统程序设计通过名字直接调用（invoking）一个进程、子例程或者函数，消息传递直接发送消息给一个进程，依赖进程或基础框架来调用实际执行的代码，并且可以分为同步方式与异步方式。

消息传递是一种通讯范型，在这种模型中由一个传信者将消息（messages）送给一个或多个收信者。

根据操作系统与编程语言的支持，消息的形式有所不同，常见的有方法（method）、信号（signals）与数据包（data packets）。

实际应用的消息传递系统有开放网络运算远程过程调用（ONC RPC）、CORBA、Java RMI、Distributed COM、SOAP。



\subsection{Messager Queue}


在计算机科学中，消息队列（Message queue）是一种进程间通信或同一进程的不同线程间的通信方式，软件的队列用来处理一系列的输入，通常是来自使用者。

消息队列提供了异步的通信协议，每一个队列中的记录包含详细说明的信息，包含发生的时间，输入装置的种类，以及特定的输入参数，也就是说消息的发送者和接收者不需要同时与消息队列交互，这样消息就会保存在队列中，直到接收者取回它。

一个 WIMP 环境（例如Microsoft Windows）可以通过优先的某些形式（通常是事件的时间或是重要性的顺序）来存储使用者产生的事件到一个事件队列中，然后系统把每个事件从事件队列中传递给目标的应用程序。


目前，有很多消息队列有很多开源的实现，包括JBoss Messaging、JORAM、Apache ActiveMQ、Sun Open Message Queue、Apache Qpid和HTTPSQS等。

实际上，消息队列常常保存在链表结构中，因此消息队列有大小限制，只有拥有权限的进程可以向消息队列中写入或读取消息。

消息队列本身是异步的，它允许接收者在消息发送很长时间后再取回消息，这导致了和大多数通信协议的不同。例如，HTTP协议就是同步的，客户端在发出请求后必须等待服务器回应。

不过，在很多情况下我们需要异步\footnote{消息队列非常独特，其本质就是一个消息的链表，因此两个进程不必同时存在，一个进程可以发送一个消息并退出，而该消息可以在数天后才被另一个进程获得。}的通信协议。例如，一个进程通知另一个进程发生了一个事件，但是不需要等待回应。

消息队列的异步特点也造成了一个缺点，就是接收者必须轮询消息队列，才能收到最近的消息。

\begin{compactitem}
\item 和信号相比，消息队列能够传递更多的信息。
\item 与管道相比，消息队列提供了有格式的数据。
\end{compactitem}


\subsection{Messager Service}

Java消息服务（Java Message Service，JMS）应用程序接口是一个Java平台中关于面向消息中间件（MOM）的API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。

Java消息服务本身是一个与具体平台无关的API，绝大多数MOM提供商都对JMS提供支持。

Java消息服务的规范包括两种消息模式，点对点和发布者/订阅者，用户可以在他们的分布式软件中实现面向消息的操作，这些操作将具有不同面向消息中间件产品的可移植性。

Java消息服务支持同步和异步的消息处理，在某些场景下，异步消息是必要的，而且在其他场景下异步消息可能比同步消息操作更加便利。

Java消息服务支持面向事件的方法接收消息，事件驱动的程序设计现在被广泛认为是一种富有成效的程序设计范例，这样在应用系统开发时，Java消息服务可以推迟选择面对消息中间件产品，也可以在不同的面对消息中间件切换。

JMS由以下元素组成：

\begin{compactitem}
\item JMS提供者
连接面向消息中间件的，JMS接口的一个实现。提供者可以是Java平台的JMS实现，也可以是非Java平台的面向消息中间件的适配器。
\item JMS客户
生产或消费消息的基于Java的应用程序或对象。
\item JMS生产者
创建并发送消息的JMS客户。
\item JMS消费者
接收消息的JMS客户。
\item JMS消息
包括可以在JMS客户之间传递的数据的对象
\item JMS队列
一个容纳那些被发送的等待阅读的消息的区域。队列暗示，这些消息将按照顺序发送。一旦一个消息被阅读，该消息将被从队列中移走。
\item JMS主题
一种支持发送消息给多个订阅者的机制。
\end{compactitem}

Java消息服务应用程序结构支持两种模型：

\begin{compactitem}
\item 点对点或队列模型
\item 发布/订阅模型
\end{compactitem}

在点对点或队列模型下，一个生产者向一个特定的队列发布消息，一个消费者从该队列中读取消息。这里，生产者知道消费者的队列，并直接将消息发送到消费者的队列，因此这种模式被概括为：

\begin{compactitem}
\item 只有一个消费者将获得消息
\item 生产者不需要在接收者消费该消息期间处于运行状态，接收者也同样不需要在消息发送时处于运行状态。
\item 每一个成功处理的消息都由接收者签收
\end{compactitem}

发布者/订阅者模型支持向一个特定的消息主题发布消息，0或多个订阅者可能对接收来自特定消息主题的消息感兴趣。

在发布者/订阅者模型下，发布者和订阅者彼此不知道对方，因此这种模式好比是匿名公告板，可以被概括为：

\begin{compactitem}
\item 多个消费者可以获得消息
\item 在发布者和订阅者之间存在时间依赖性。发布者需要建立一个订阅（subscription），以便客户能够购订阅。订阅者必须保持持续的活动状态以接收消息，除非订阅者建立了持久的订阅。在那种情况下，在订阅者未连接时发布的消息将在订阅者重新连接时重新发布。
\end{compactitem}

JMS提供了将应用与提供数据的传输层相分离的方式，同一组Java类可以通过JNDI中关于提供者的信息，连接不同的JMS提供者。这一组类首先使用一个连接工厂以连接到队列或主题，然后发送或发布消息。在接收端，客户接收或订阅这些消息。

Java消息服务的API在javax.jms包中提供，具体内容包括：

\begin{compactitem}
\item ConnectionFactory 接口（连接工厂）

用户用来创建到JMS提供者的连接的被管对象。JMS客户通过可移植的接口访问连接，这样当下层的实现改变时，代码不需要进行修改。 管理员在JNDI名字空间中配置连接工厂，这样，JMS客户才能够查找到它们。根据消息类型的不同，用户将使用队列连接工厂，或者主题连接工厂。



\item Connection 接口（连接）

连接代表了应用程序和消息服务器之间的通信链路。在获得了连接工厂后，就可以创建一个与JMS提供者的连接。根据不同的连接类型，连接允许用户创建会话，以发送和接收队列和主题到目标。



\item Destination 接口（目标）

目标是一个包装了消息目标标识符的被管对象，消息目标是指消息发布和接收的地点，或者是队列，或者是主题。JMS管理员创建这些对象，然后用户通过JNDI发现它们。和连接工厂一样，管理员可以创建两种类型的目标，点对点模型的队列，以及发布者／订阅者模型的主题。



\item MessageConsumer 接口（消息消费者）

由会话创建的对象，用于接收发送到目标的消息。消费者可以同步地（阻塞模式），或异步（非阻塞）接收队列和主题类型的消息。



\item MessageProducer 接口（消息生产者）

由会话创建的对象，用于发送消息到目标。用户可以创建某个目标的发送者，也可以创建一个通用的发送者，在发送消息时指定目标。



\item Message 接口（消息）

是在消费者和生产者之间传送的对象，也就是说从一个应用程序创送到另一个应用程序。一个消息有三个主要部分：

\begin{compactenum}
\item 消息头（必须）：包含用于识别和为消息寻找路由的操作设置。
\item 一组消息属性（可选）：包含额外的属性，支持其他提供者和用户的兼容。可以创建定制的字段和过滤器（消息选择器）。
\item 一个消息体（可选）：允许用户创建五种类型的消息（文本消息，映射消息，字节消息，流消息和对象消息）。
\end{compactenum}

消息接口非常灵活，并提供了许多方式来定制消息的内容。

\item Session 接口（会话）

表示一个单线程的上下文，用于发送和接收消息。由于会话是单线程的，所以消息是连续的，就是说消息是按照发送的顺序一个一个接收的。会话的好处是它支持事务。如果用户选择了事务支持，会话上下文将保存一组消息，直到事务被提交才发送这些消息。在提交事务之前，用户可以使用回滚操作取消这些消息。一个会话允许用户创建消息生产者来发送消息，创建消息消费者来接收消息。

\end{compactitem}

要使用Java消息服务，必须要有一个JMS提供者来管理会话和队列。现在既有开源的提供者也有专有的提供者。

如果计划在一个服务器集群中运行程序，需要检查提供者是否实现了对负载均衡和故障恢复的支持。

\section{Async}


\subsection{AJAX}

AJAX（Asynchronous JavaScript and XML，异步的JavaScript与XML技术）综合了多项技术来支持浏览器端的网页开发。

与传统的Web应用允许用户端填写表单（form）并提交不同，当用户提交表单时就向Web服务器发送一个请求，服务器接收并处理传来的表单，然后送回一个新的网页，这个做法浪费了许多带宽。

在前后两个页面中的大部分HTML码往往是相同的，每次应用的沟通都需要向服务器发送请求，应用的回应时间依赖于服务器的回应时间，因此这也导致了用户界面的回应比本机应用慢得多。

AJAX应用可以仅向服务器发送并取回必须的数据，并在客户端采用JavaScript处理来自服务器的回应，在服务器和浏览器之间交换的数据大量减少（大约只有原来的5\%），因此服务器回应更快了。同时，很多的处理工作可以在发出请求的客户端机器上完成，因此Web服务器的负荷也减少了。

类似于DHTML或LAMP，AJAX不是指一种单一的技术，而是有机地利用了一系列相关的技术。例如，虽然其名称包含XML，但实际上数据格式可以由JSON代替以进一步减少数据量，形成所谓的AJAJ。

客户端与服务器也可以不需要异步，例如一些基于AJAX的“派生/合成”式（derivative/composite）的技术也正在出现，如AFLAX。





\subsection{Method}

异步方法调用或异步方法模式是（多线程）面向对象程序设计中用于异步调用对象的潜在的长期运行方法的一种设计模式。

异步方法调用等价于Allan Vermeulen提出的IOU模式，基于事件的异步模式是异步方法调用的一个变种，开销更大但能更好的表现软件组件对象。

.NET框架和Java中的java.util.concurrent.FutureTask类中使用的基于事件的异步模式使用事件来解决同样的问题，而且异步事件处理函数库libevent通过一组API来让用户可以设定某些事件发生时所执行的函数，也就是说，libevent可以用来取代网络服务器所使用的事件循环检查框架。



具体来说，libevent支持poll、select、/dev/pool、kqueue和epoll等方式来判断IO事件，这样libevent就省略了对网络的处理，并且拥有不错的性能，因此被memcached和tor等软件作为网络底层的函数库。

大部分编程语言中对方法的调用是同步执行的。例如，在线程执行体内（即线程的调用函数中），方法的调用就是同步执行的。

如果方法需要很长的时间来完成，比方说从Internet加载数据的方法，调用者线程将被阻塞直到方法调用完成。如果不希望调用被阻塞，则可以通过创建新的worker线程并在worker线程中调用方法，在大多数编程环中上这样做可能需要很长的一段代码，尤其是需要小心处理线程过多的额外开销。

异步方法调用它通过使用一种立即返回的异步的变体并提供额外的方法来支持接受完成通知以及完成等待改进长期运行的（同步）方法。

活动对象（active object）设计模式通常使用异步方法调用，异步方法调用的一个替代方案是同步的方法调用和未来对象（future object）模式。



在Web浏览器的实现上可以采用异步方法调用，例如浏览器需要在Web页面中的图像加载完成之前将页面显示出来。


\subsection{Pattern}

在计算机科学中，参与者模式（Actor model）是一种并发运算上的模型。

“参与者”是一种程序上的抽象概念，被视为并发运算的基本单元：当一个参与者接收到一则消息，它可以做出一些决策、创建更多的参与者、发送更多的消息、决定要如何回答接下来的消息。

参与者模型推崇的哲学是“一切皆是参与者”，与面向对象编程的“一切皆是对象”类似，但是面向对象编程通常是顺序执行的，而参与者模型是并行执行的。

参与者是一个运算实体，回应接受到的消息，同时并行的：

\begin{compactitem}
\item 发送有限数量的消息给其他参与者；
\item 创建有限数量的新参与者；
\item 指定接受到下一个消息时的行为。
\end{compactitem}

以上操作不含有顺序执行的假设，因此可以并行进行。

发送者与已经发送的消息解耦是参与者模型的根本优势，这样就允许进行异步通信，同时满足消息传递的控制结构。

消息接收者是通过地址区分的，有时也被称作“邮件地址”，因此参与者只能和它拥有地址的参与者通信，它可以通过接受到的信息获取地址，或者获取它创建的参与者的地址。

参与者模型的特征是，参与者内部或之间进行并行计算，参与者可以动态创建，参与者地址包含在消息中，交互只有通过直接的异步消息通信，不限制消息到达的顺序。



\subsection{Task}



在Server程序中如果需要执行一下很耗时的操作，比如一个聊天服务器发送广播，Web服务器中发送邮件。如果直接去执行这些函数就会阻塞当前进程，导致服务器响应变慢。

与旧版本（<=2.2）的Apache不同，nginx不采用每客户机一线程的设计模型，而是充分使用异步逻辑来削减上下文调度开销，所以并发服务能力更强，可以支持大量的平行连接。

PHP-FPM自PHP-5.3.3起开始加入到了PHP核心，编译时加上\texttt{--enable-fpm}就可以提供支持，然后PHP-FPM以守护进程在后台运行，在Nginx响应请求后，自行处理静态请求，PHP请求则经过\texttt{fastcgi\_pass}交由PHP-FPM处理并在处理完毕后返回，因此Nginx和PHP-FPM的组合成为了一种稳定、高效的PHP运行方式，效率要比传统的Apache和mod\_php高出不少。

Node.js提供事件驱动和非阻塞I/O API，其设计目标是任何需要操作I/O的函数都使用回调函数，可以优化应用程序的吞吐量和规模，这些技术通常被用于实时应用程序。

libuv是一个网络和文件系统功能的抽象层，既可以用于Windows又可以用于符合POSIX标准的系统（例如Linux、OS X和Unix），同时Node.js使用libuv来处理异步事件，而且V8提供了JavaScript的实时运行环境。

\begin{lstlisting}[language=PHP]
var http = require('http');

http.createServer(function(request, response){
	response.writeHead(200,{'Content-Type': 'text/plain'});
	resposne.end('Hello World\n');
}).listen(8000);

console.log('Server running at http://127.0.0.1:8000/');
\end{lstlisting}

基于Node.js也可以实现简单的TCP服务器，并监听端口7000来输出（echo）之前输入的消息：

\begin{lstlisting}[language=PHP]
var net = require('net');

net.createServer(function (stream){
	stream.write('hello\n');
	
	stream.on('end',function(){
		stream.end('goodbye\r\n');
	});
	stream.pipe(stream);
}).listen(7000);
\end{lstlisting}

Redis数据库将全部的数据存储在内存中，并且使用快照以半持久耐用模式将数据集以异步方式从内存以RDB格式写入硬盘。

Swoole提供了异步任务处理的功能，可以投递一个异步任务到TaskWorker进程池中执行，不影响当前请求的处理速度。

基于第一个TCP服务器，只需要增加onTask和onFinish2个事件回调函数就可以实现异步任务处理。



\begin{lstlisting}[language=PHP]
//创建swoole_server对象，在127.0.0.1监听9501端口
$tcpserver = new swoole_server("127.0.0.1", 9501);

$tcpserver->set(array(
    'worker_num' => 8,   //工作进程数量
    'daemonize' => 0, //是否作为守护进程
    'task_worker_num' => 4 // 设置异步任务的工作进程数量
));

// 监听连接进入事件
$tcpserver->on('connect', function ($tcpserver, $fd){
    echo "Client:Connect.\n";
});

//监听数据发送事件
$tcpserver->on('receive', function ($tcpserver, $fd, $from_id, $data) {
    $tcpserver->send($fd, 'Swoole TCP Server: '.$data);
    // //投递异步任务
    $task_id = $tcpserver->task($data);
    echo "Dispatch AsyncTask: id = $task_id\n";
    $tcpserver->close($fd);
});

// 处理异步任务
$tcpserver->on('task',function($tcpserver,$task_id,$fram_id,$data){
	echo "New AsyncTask[id=$task_id]" . PHP_EOL;
	// 返回任务执行的结果
	$tcpserver->finish("$data-> OK");
});

// 处理异步任务的结果
$tcpserver->on('finish',function($tcpserver,$task_id,$data){
	echo "AsyncTask[$task_id] Finish: $data" . PHP_EOL;
});

//监听连接关闭事件
$tcpserver->on('close', function ($tcpserver, $fd) {
    echo "Client: Close.\n";
});

//启动服务器
$tcpserver->start();
\end{lstlisting}


另外，需要设置task进程数量，可以根据任务的耗时和任务量配置适量的task进程。


在异步处理任务过程中，调用\texttt{\$tcpserver->task()}后，程序立即返回，继续向下执行代码。onTask回调函数Task在进程池内被异步执行，执行完成后调用\texttt{\$tcpserver->finish()}返回结果。

注意，finish操作是可选的，也可以不返回任何结果。


\chapter{Swoole}


Swoole不仅支持异步，还支持同步。什么情况下使用同步，什么情况下使用异步。这里说明一下。


我们不赞成用异步回调的方式去做功能开发，传统的PHP同步方式实现功能和逻辑是最简单的，也是最佳的方案。过度使用回调（例如Node.js）或者到处callback，只是牺牲可维护性和开发效率。

但是，有些时候很适合用异步，比如FTP、聊天服务器，smtp，代理服务器等应用以通信和读写磁盘为主，功能和业务逻辑其次的服务器程序。


“PHP的扩展函数API全是同步的”，这个说法并不正确，实际上同步阻塞的地方主要是网络调用，文件读写。例如mysql\_query需要与mysql数据库服务器通信，curl需要调用网络，file\_get\_contents需要读写文件，以及其他fopen/fwrite/fread/fgets/fputs这些都是阻塞的API。除此之外，PHP的array/string/mbstring等函数是非阻塞的。

swoole提供了异步的socket客户端，异步的mysql，而且1.6.12还提供了异步文件读写和异步DNS查询的功能。

另外，Swoole还提供了task/finish的API，完全可以解决阻塞IO问题。
